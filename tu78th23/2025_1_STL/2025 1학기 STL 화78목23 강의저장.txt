//------------------------------------------------------------------------
// 2025.03.06 STL 목23											 (1주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 한 학기 강의를 저장할 수 있는 save 기능 작성
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>
#include <vector>
#include <algorithm>

// [문제] save할 수 있는 코드를 작성하고 실행되게 하라!

void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL 시작" << std::endl;

	save("name.cpp");
}

//----------------------------------
void save(std::string_view fileName)
//----------------------------------
{
	// 파일 fileName을 연다
	std::ifstream in{ fileName.data()}; // data()는 const char*로 변환해줌
	if (not in) { // !in 이 아닌 not in 으로 적을것
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 저장했음을 화면에 출력하자
	auto size = std::filesystem::file_size(fileName);
	std::cout << fileName << " - " << size << " 바이트를 저장하였습니다." << std::endl;

	// 저장할 파일도 열어야 한다
	std::ofstream out{ "2025 1학기 STL 화78목23 강의저장.txt", std::ios::app };

	// 읽을 파일의 내용을 읽어서 저장할 파일에 덧붙인다
	std::vector<char> v(size); // 컨테이너의 메모리 확보
	std::copy(std::istreambuf_iterator{ in }, {}, v.begin()); // std::istreambuf_iterator{in} : 저장할 파일에 첫번째 바이트 // 파일을 메모리로
	std::copy(v.begin(), v.end(), std::ostreambuf_iterator{ out }); // 메모리를 파일로
}                                                   //------------------------------------------------------------------------
// 2025.03.06 STL 목23											 (1주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 한 학기 강의를 저장할 수 있는 save 기능 작성
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>
#include <algorithm>

// [문제] save할 수 있는 코드를 작성하고 실행되게 하라!

void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL 시작" << std::endl;

	save("name.cpp");
}

//----------------------------------
void save(std::string_view fileName)
//----------------------------------
{
	// 파일 fileName을 연다
	std::ifstream in{ fileName.data()}; // data()는 const char*로 변환해줌
	if (not in) { // !in 이 아닌 not in 으로 적을것
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 저장했음을 화면에 출력하자
	auto size = std::filesystem::file_size(fileName);
	std::cout << fileName << " - " << size << " 바이트를 저장하였습니다." << std::endl;

	// 저장할 파일도 열어야 한다
	std::ofstream out{ "2025 1학기 STL 화78목23 강의저장.txt", std::ios::app };

	// 읽을 파일의 내용을 읽어서 저장할 파일에 덧붙인다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out }); 
	// std::istreambuf_iterator{in} : 저장할 파일에 첫번째 바이트 // 파일을 메모리로
}//------------------------------------------------------------------------
// 2025.03.06 STL 목23											 (1주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 한 학기 강의를 저장할 수 있는 save 기능 작성
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>
#include <algorithm>
#include <chrono>

// [문제] save할 수 있는 코드를 작성하고 실행되게 하라!

void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL 시작" << std::endl;

	save("name.cpp");
}

//----------------------------------
void save(std::string_view fileName)
//----------------------------------
{
	// 파일 fileName을 연다
	std::ifstream in{ fileName.data()}; // data()는 const char*로 변환해줌
	if (not in) { // !in 이 아닌 not in 으로 적을것
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 저장했음을 화면에 출력하자
	std::cout << fileName << " - " << std::filesystem::file_size(fileName) << " 바이트를 저장하였습니다." << std::endl;

	// 저장할 파일도 열어야 한다
	std::ofstream out{ "2025 1학기 STL 화78목23 강의저장.txt", std::ios::app };

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now(); // time_point를 얻는다
	std::cout << now << std::endl;

	// 읽을 파일의 내용을 읽어서 저장할 파일에 덧붙인다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out }); 
}//------------------------------------------------------------------------
// 2025.03.06 STL 목23											 (1주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 한 학기 강의를 저장할 수 있는 save 기능 작성
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>
#include <algorithm>
#include <chrono>

// [문제] save할 수 있는 코드를 작성하고 실행되게 하라!

void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL 시작" << std::endl;

	save("name.cpp");
}

//----------------------------------
void save(std::string_view fileName)
//----------------------------------
{
	// 파일 fileName을 연다
	std::ifstream in{ fileName.data()}; // data()는 const char*로 변환해줌
	if (not in) { // !in 이 아닌 not in 으로 적을것
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 저장했음을 화면에 출력하자
	std::cout << fileName << " - " << std::filesystem::file_size(fileName) << " 바이트를 저장하였습니다." << std::endl;

	// 저장할 파일도 열어야 한다
	std::ofstream out{ "2025 1학기 STL 화78목23 강의저장.txt", std::ios::app };

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now(); // time_point를 얻는다
	using namespace std::chrono_literals;
	std::cout << now + 9h << std::endl;

	// 읽을 파일의 내용을 읽어서 저장할 파일에 덧붙인다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out }); 
}

==================================================
저장시간2025-03-06 오전 11:57:09 목요일
==================================================

//------------------------------------------------------------------------
// 2025.03.06 STL 목23											 (1주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 한 학기 강의를 저장할 수 있는 save 기능 작성
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>
#include <algorithm>
#include <chrono>

// [문제] save할 수 있는 코드를 작성하고 실행되게 하라!

void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL 시작" << std::endl;

	save("name.cpp");
}

//----------------------------------
void save(std::string_view fileName)
//----------------------------------
{
	// 파일 fileName을 연다
	std::ifstream in{ fileName.data()}; // data()는 const char*로 변환해줌
	if (not in) { // !in 이 아닌 not in 으로 적을것
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 저장했음을 화면에 출력하자
	std::cout << fileName << " - " << std::filesystem::file_size(fileName) << " 바이트를 저장하였습니다." << std::endl;

	// 저장할 파일도 열어야 한다
	std::ofstream out{ "2025 1학기 STL 화78목23 강의저장.txt", std::ios::app };

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now(); // time_point를 얻는다
	auto utc = std::chrono::system_clock::to_time_t(now); // time_point를 UTC시간으로 변경
	auto lt = std::localtime(&utc); // 지역시간으로 변경
	auto old = out.imbue(std::locale("ko_KR")); // out의 지역을 한국으로
	
	out << '\n' << '\n';
	out << "==================================================" << '\n';
	out << "저장시간" << std::put_time(lt, "%c %A") << '\n';
	out << "==================================================" << '\n';
	out << '\n';
	out.imbue(old);

	// 읽을 파일의 내용을 읽어서 저장할 파일에 덧붙인다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out }); 
}

==================================================
저장한 시간 : 2025-03-06 오전 11:58:27 목요일
==================================================

//------------------------------------------------------------------------
// 2025.03.06 STL 목23											 (1주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 한 학기 강의를 저장할 수 있는 save 기능 작성
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>
#include <algorithm>
#include <chrono>

// [문제] save할 수 있는 코드를 작성하고 실행되게 하라!

void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL 시작" << std::endl;

	save("name.cpp");
}

//----------------------------------
void save(std::string_view fileName)
//----------------------------------
{
	// 파일 fileName을 연다
	std::ifstream in{ fileName.data()}; // data()는 const char*로 변환해줌
	if (not in) { // !in 이 아닌 not in 으로 적을것
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 저장했음을 화면에 출력하자
	std::cout << fileName << " - " << std::filesystem::file_size(fileName) << " 바이트를 저장하였습니다." << std::endl;

	// 저장할 파일도 열어야 한다
	std::ofstream out{ "2025 1학기 STL 화78목23 강의저장.txt", std::ios::app };

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now(); // time_point를 얻는다
	auto utc = std::chrono::system_clock::to_time_t(now); // time_point를 UTC시간으로 변경
	auto lt = std::localtime(&utc); // 지역시간으로 변경
	auto old = out.imbue(std::locale("ko_KR")); // out의 지역을 한국으로
	
	out << '\n' << '\n';
	out << "==================================================" << '\n';
	out << "저장한 시간 : " << std::put_time(lt, "%c %A") << '\n';
	out << "==================================================" << '\n';
	out << '\n';
	out.imbue(old);

	// 읽을 파일의 내용을 읽어서 저장할 파일에 덧붙인다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out }); 
}

================================
저장한 시간 : 2025-03-06 오후 12:03:35 목요일
================================

//------------------------------------------------------------------------
// 2025.03.06 STL 목23											 (1주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 한 학기 강의를 저장할 수 있는 save 기능 작성
// 과제 - save 기능을 save.cpp로 분리하라
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>
#include <algorithm>
#include <chrono>

// [문제] save할 수 있는 코드를 작성하고 실행되게 하라!

void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL 시작" << std::endl;

	save("name.cpp");
}

////----------------------------------
//void save(std::string_view fileName)
////----------------------------------
//{
//	// 파일 fileName을 연다
//	std::ifstream in{ fileName.data()}; // data()는 const char*로 변환해줌
//	if (not in) { // !in 이 아닌 not in 으로 적을것
//		std::cout << fileName << "을 열 수 없습니다." << std::endl;
//		exit(20250306);
//	}
//
//	// 저장했음을 화면에 출력하자
//	std::cout << fileName << " - " << std::filesystem::file_size(fileName) << " 바이트를 저장하였습니다." << std::endl;
//
//	// 저장할 파일도 열어야 한다
//	std::ofstream out{ "2025 1학기 STL 화78목23 강의저장.txt", std::ios::app };
//
//	// 저장한 시간을 파일에 기록하자
//	auto now = std::chrono::system_clock::now(); // time_point를 얻는다
//	auto utc = std::chrono::system_clock::to_time_t(now); // time_point를 UTC시간으로 변경
//	auto lt = std::localtime(&utc); // 지역시간으로 변경
//	auto old = out.imbue(std::locale("ko_KR")); // out의 지역을 한국으로
//	
//	out << '\n' << '\n';
//	out << "================================" << '\n';
//	out << "저장한 시간 : " << std::put_time(lt, "%c %A") << '\n';
//	out << "================================" << '\n';
//	out << '\n';
//	out.imbue(old);
//
//	// 읽을 파일의 내용을 읽어서 저장할 파일에 덧붙인다
//	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out }); 
//}

================================
저장한 시간 : 2025-03-06 오후 12:04:31 목요일
================================

//------------------------------------------------------------------------
// 2025.03.06 STL 목23											 (1주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 한 학기 강의를 저장할 수 있는 save 기능 작성
// 과제 - save 기능을 save.cpp로 분리하라
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>

// [문제] save할 수 있는 코드를 작성하고 실행되게 하라!

void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL 시작" << std::endl;

	save("name.cpp");
}

================================
저장한 시간 : 2025-03-11 오후 3:42:50 화요일
================================

//------------------------------------------------------------------------
// 2025.03.06 STL 목23											 (2주 1일)
//------------------------------------------------------------------------
// save 파일 분리 / tamplate 복습
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
// C++ 에서 사용하지 말하야할 것
// 1. char* (문자열)(X) -> string -> string_view
// 2. T*(X) -> unique_ptr<T>, shared_ptr<T>
// 3. T[N] (X) -> array<T, N>

#include <iostream>

// [문제] save할 수 있는 코드를 작성하고 실행되게 하라!

void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL 시작" << std::endl;

	save("0311.cpp");
}

================================
저장한 시간 : 2025-03-11 오후 3:45:23 화요일
================================

//------------------------------------------------------------------------
// 2025.03.06 STL 목23											 (2주 1일)
//------------------------------------------------------------------------
// save 파일 분리 / tamplate 복습
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
// C++ 에서 사용하지 말하야할 것
// 1. char* (문자열)(X) -> string -> string_view
// 2. T*(X) -> unique_ptr<T>, shared_ptr<T>
// 3. T[N] (X) -> array<T, N>

#include <iostream>

// [문제] save할 수 있는 코드를 작성하고 실행되게 하라!

void save(std::string_view);

//--------
int main()
//--------
{
	std::cout << "2025 STL 시작" << std::endl;

	save("0311.cpp");
}

================================
저장한 시간 : 2025-03-11 오후 3:54:02 화요일
================================

//------------------------------------------------------------------------
// 2025.03.06 STL 목23											 (2주 1일)
//------------------------------------------------------------------------
// save 파일 분리 / tamplate 복습
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
// C++ 에서 사용하지 말하야할 것
// 1. char* (문자열)(X) -> string -> string_view
// 2. T*(X) -> unique_ptr<T>, shared_ptr<T>
// 3. T[N] (X) -> array<T, N>

#include <iostream>
#include "save.h"

// [문제] save할 수 있는 코드를 작성하고 실행되게 하라!



//---------
int main()
//---------
{
	std::cout << "2025 STL 시작" << std::endl;

	save("0311.cpp");
}

================================
저장한 시간 : 2025-03-11 오후 3:54:35 화요일
================================

//------------------------------------------------------------------------
// 2025.03.06 STL 목23											 (2주 1일)
//------------------------------------------------------------------------
// save 파일 분리 / tamplate 복습
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
// C++ 에서 사용하지 말하야할 것
// 1. char* (문자열)(X) -> string -> string_view
// 2. T*(X) -> unique_ptr<T>, shared_ptr<T>
// 3. T[N] (X) -> array<T, N>

#include <iostream>
#include "save.h"

// [문제] save할 수 있는 코드를 작성하고 실행되게 하라!



//---------
int main()
//---------
{
	std::cout << "2025 STL 시작" << std::endl;

	save("0311.cpp");
	save("save.h");
	save("save.cpp");
}

================================
저장한 시간 : 2025-03-11 오후 3:54:35 화요일
================================

//---------------------------------------------------------
// save.h										2025.03.11
//---------------------------------------------------------
#pragma once
void save(std::string_view);

================================
저장한 시간 : 2025-03-11 오후 3:54:35 화요일
================================

//---------------------------------------------------------
// save.cpp										2025.03.11
// 
// 한 학기 강의를  저장한다.
//---------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>
#include <algorithm>
#include <chrono>

//----------------------------------
void save(std::string_view fileName)
//----------------------------------
{
	// 파일 fileName을 연다
	std::ifstream in{ fileName.data() }; // data()는 const char*로 변환해줌
	if (not in) { // !in 이 아닌 not in 으로 적을것
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	// 저장할 파일도 열어야 한다
	std::string writeFile{ "2025 1학기 STL 화78목23 강의저장.txt" };
	std::ofstream out{ writeFile, std::ios::app };

	// 저장했음을 화면에 출력하자
	std::cout << writeFile << "에 " << fileName << "을 덧붙였습니다 - " 
		<< std::filesystem::file_size(fileName) << " bytes" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now(); // time_point를 얻는다
	auto utc = std::chrono::system_clock::to_time_t(now); // time_point를 UTC시간으로 변경
	auto lt = std::localtime(&utc); // 지역시간으로 변경
	auto old = out.imbue(std::locale("ko_KR")); // out의 지역을 한국으로

	out << '\n' << '\n';
	out << "================================" << '\n';
	out << "저장한 시간 : " << std::put_time(lt, "%c %A") << '\n';
	out << "================================" << '\n';
	out << '\n';
	out.imbue(old);

	// 읽을 파일의 내용을 읽어서 저장할 파일에 덧붙인다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}

================================
저장한 시간 : 2025-03-11 오후 4:22:32 화요일
================================

//------------------------------------------------------------------------
// 2025.03.11 STL 화78											 (2주 1일)
//------------------------------------------------------------------------
// save 파일 분리 / tamplate 복습
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
// C++ 에서 사용하지 말하야할 것
// 1. char* (문자열)(X) -> string -> string_view
// 2. T*(X) -> unique_ptr<T>, shared_ptr<T>
// 3. T[N] (X) -> array<T, N>

#include <iostream>
#include "save.h"
//using namespace std; // 절대 이렇게 하지 말자

// [문제] main을 수정하면 안됨. 의도대로 실행되게 하자

class Dog {
public:
	int number;

	
	void change(Dog&, Dog&);
};

void change(Dog& a, Dog& b) {
	int temp{ a.number };
	a.number = b.number;
	b.number = temp;
}

void change(int&, int&);

//---------
int main()
//---------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a.number << ", " << b.number << std::endl; // 의도 - 2, 1 출력
	}


	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl; // 의도 - 2, 1 출력
	}

	save("0311.cpp");
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

================================
저장한 시간 : 2025-03-11 오후 4:49:31 화요일
================================

//------------------------------------------------------------------------
// 2025.03.11 STL 화78											 (2주 1일)
//------------------------------------------------------------------------
// save 파일 분리 / tamplate 복습
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
// C++ 에서 사용하지 말하야할 것
// 1. char* (문자열)(X) -> string -> string_view
// 2. T*(X) -> unique_ptr<T>, shared_ptr<T>
// 3. T[N] (X) -> array<T, N>

#include <iostream>
#include "save.h"
//using namespace std; // 절대 이렇게 하지 말자

// [문제] main을 수정하면 안됨. 의도대로 실행되게 하자
// [질문] C++에서 change를 몇 개나 만들어야 하나?

class Dog {
public:
	Dog() = default;
	Dog(int n) : num{ n } {}
	
	//operator int() {
	//	return num;
	//} 
	// 간단하지만 사용하지 않는게 나은 코드다. 
private:
	int num{ };
	
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.num;
	}
};

void change(int&, int&);
void change(Dog&, Dog&);


//---------
int main()
//---------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl; // 의도 - 2, 1 출력
	}


	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl; // 의도 - 2, 1 출력
	}

	save("0311.cpp");
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b) {
	Dog temp{ a }; // 복사 생성자는 매우 특별한 동작, 프로그래머가 코딩하지않아도 만들어준다
	a = b; // 원래는 a.operator = (b);라는 함수인데 이것 또한 간단하게 만들어준다
	b = temp;
}

================================
저장한 시간 : 2025-03-11 오후 5:05:59 화요일
================================

//------------------------------------------------------------------------
// 2025.03.11 STL 화78											 (2주 1일)
//------------------------------------------------------------------------
// save 파일 분리 / Generic Programming의 핵심 - tamplate
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
// C++ 에서 사용하지 말하야할 것
// 1. char* (문자열)(X) -> string -> string_view
// 2. T*(X) -> unique_ptr<T>, shared_ptr<T>
// 3. T[N] (X) -> array<T, N>

#include <iostream>
#include "save.h"
//using namespace std; // 절대 이렇게 하지 말자

// [문제] main을 수정하면 안됨. 의도대로 실행되게 하자

class Dog {
public:
	Dog() = default;
	Dog(int n) : num{ n } {}
	
	//operator int() {
	//	return num;
	//} 
	// 간단하지만 사용하지 않는게 나은 코드다. 
private:
	int num{ };
	
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.num;
	}
};

// [질문] C++에서 change를 몇 개나 만들어야 하나?
// -- C++ 언어의 자료형은 몇 개나 있나? a. 자료형은 무한하다. -> 소스코드를 자동 생성하자
// C++ template
template <class Obj>
void change(Obj&, Obj&);


//---------
int main()
//---------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl; // 의도 - 2, 1 출력
	}


	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl; // 의도 - 2, 1 출력
	}

	save("0311.cpp");
}

// template은 선언과 정의를 분리하지 않는다.

template <class T>
void change(T& a, T& b) {
	T temp{ a }; // 복사 생성자는 매우 특별한 동작, 프로그래머가 코딩하지않아도 만들어준다
	a = b; // 원래는 a.operator = (b);라는 함수인데 이것 또한 간단하게 만들어준다
	b = temp;
}

================================
저장한 시간 : 2025-03-13 오전 10:48:00 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 화면에 출력하라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	for (int i{ 0 }; i < 1000; ++i) {
		std::cout << uid(dre) << " ";
	}
	std::cout << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 10:49:19 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 화면에 출력하라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ std::random_device{}()}; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	std::cout << uid(dre) << " ";
	/*for (int i{ 0 }; i < 1000; ++i) {
		std::cout << uid(dre) << " ";
	}
	std::cout << std::endl;*/

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 10:50:50 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 화면에 출력하라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	for (int i = 0; i < 1000; ++i)
		std::cout << uid(dre) << " ";

	std::cout << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 10:53:50 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	for (int i = 0; i < 1000; ++i)
		std::print("{:80}", uid(dre));

	std::cout << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 10:54:56 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	for (int i = 0; i < 1000; ++i)
		std::print("{:^80}", uid(dre));

	std::cout << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 10:55:03 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	for (int i = 0; i < 1000; ++i)
		std::print("{:^80}", uid(dre));

	std::cout << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 10:55:33 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	for (int i = 0; i < 1000; ++i)
		std::print("{:8}", uid(dre));

	std::cout << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 11:00:06 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	int rand_number[1000];
	int max = 0;
	for (int i = 0; i < 1000; ++i) {
		rand_number[i] = uid(dre);
		if (max < rand_number[i]) max = rand_number[i];
	}

	std::print(":8", max);

	std::cout << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 11:00:28 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	int rand_number[1000];
	int max = 0;
	for (int i = 0; i < 1000; ++i) {
		rand_number[i] = uid(dre);
		if (max < rand_number[i]) max = rand_number[i];
	}

	std::print("{:8}", max);

	std::cout << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 11:00:32 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	int rand_number[1000];
	int max = 0;
	for (int i = 0; i < 1000; ++i) {
		rand_number[i] = uid(dre);
		if (max < rand_number[i]) max = rand_number[i];
	}

	std::print("{:8}", max);

	std::cout << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 11:00:35 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	int rand_number[1000];
	int max = 0;
	for (int i = 0; i < 1000; ++i) {
		rand_number[i] = uid(dre);
		if (max < rand_number[i]) max = rand_number[i];
	}

	std::print("{:8}", max);

	std::cout << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 11:00:45 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	int rand_number[1000];
	int max = 0;
	for (int i = 0; i < 1000; ++i) {
		rand_number[i] = uid(dre);
		if (max < rand_number[i]) max = rand_number[i];
	}

	std::print("{:8}", max);

	std::cout << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 11:01:37 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	int rand_number[1000];
	int max = 0;
	for (int i = 0; i < 1000; ++i) {
		rand_number[i] = uid(dre);
		if (max < rand_number[i]) max = rand_number[i];
	}

	std::print("{:8}", max);

	std::cout << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 11:11:30 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <print>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	int rand_number[1000];
	for (int i = 0; i < 1000; ++i) rand_number[i] = uid(dre);

	// 가장 큰 값을 찾기
	int maxValue{ std::numeric_limits<int>::min()};
	for (int num : rand_number) {
		if (maxValue < num)
			maxValue = num;
	}

	std::cout << "최댓값 - " << maxValue << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 11:14:45 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <array> // STL sequence container 중 하나
#include <print>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	std::array<int, 1000> a; 
	for (int i = 0; i < 1000; ++i) a[i] = uid(dre);

	// 가장 큰 값을 찾기
	int maxValue{ std::numeric_limits<int>::min()};
	for (int num : a) {
		if (maxValue < num)
			maxValue = num;
	}

	std::cout << "최댓값 - " << maxValue << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 11:23:32 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <array> // STL sequence container 중 하나
#include <print>
#include <algorithm> // 여기있는 걸 기능을 코딩하면 안된다
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	std::array<int, 1000> a;

	for (int i = 0; i < 1000; ++i) a[i] = uid(dre);

	// 가장 큰 값을 찾기
	auto 가장큰값의위치 = std::max_element(a.begin(), a.end());

	std::cout << "최댓값 - " << *가장큰값의위치 << std::endl;

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 11:52:56 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - FILE에 저장하고 읽어오기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <array> // STL sequence container 중 하나
#include <print>
#include <algorithm> // 여기있는 걸 기능을 코딩하면 안된다
#include <fstream>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	std::array<int, 1000> a;

	for (int i = 0; i < 1000; ++i) a[i] = uid(dre);

	// 가장 큰 값을 찾기

	std::cout << "최댓값 - " << *std::max_element(a.begin(), a.end()) << std::endl;

	// [문제] a에 있는 값을 파일 "int 1000개.txt"에 텍스트 그대로 저장하라
	// 화면 출력한 것과 같은 형태로 - 파일을 열었을 때 int값을 사람이 읽을 수 있도록

	std::ofstream out{ "int 1000개.txt"}; //RAII

	for (int num : a)
		std::print(out, "{:8}", num);

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오전 11:54:37 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - FILE에 저장하고 읽어오기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <array> // STL sequence container 중 하나
#include <print>
#include <algorithm> // 여기있는 걸 기능을 코딩하면 안된다
#include <fstream>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	std::array<int, 1000> a;

	for (int i = 0; i < 1000; ++i) a[i] = uid(dre);

	// 가장 큰 값을 찾기

	std::cout << "최댓값 - " << *std::max_element(a.begin(), a.end()) << std::endl;

	// [문제] a에 있는 값을 파일 "int 1000개.txt"에 텍스트 그대로 저장하라
	// 화면 출력한 것과 같은 형태로 - 파일을 열었을 때 int값을 사람이 읽을 수 있도록

	std::ofstream out{ "int 1000개.txt"}; //RAII
	int i{ 0 };
	for (int num : a) {
		std::print(out, "{:8}", num);
		if (not(++i % 8))
			out << std::endl;
	}

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오후 12:00:05 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - FILE에 저장하고 읽어오기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <array> // STL sequence container 중 하나
#include <print>
#include <algorithm> // 여기있는 걸 기능을 코딩하면 안된다
#include <fstream>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	std::array<int, 1000> a;

	for (int i = 0; i < 1000; ++i) a[i] = uid(dre);

	// 가장 큰 값을 찾기

	std::cout << "최댓값 - " << *std::max_element(a.begin(), a.end()) << std::endl;

	// [문제] a에 있는 값을 파일 "int 1000개.txt"에 텍스트 그대로 저장하라
	// 화면 출력한 것과 같은 형태로 - 파일을 열었을 때 int값을 사람이 읽을 수 있도록

	std::ofstream out{ "int 1000개.txt"}; //RAII
	int i{ 0 };
	for (int num : a) {
		std::print(out, "{:8}", num);
		if (not(++i % 8))
			out << std::endl;
	}

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오후 12:01:53 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - FILE에 저장하고 읽어오기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <array> // STL sequence container 중 하나
#include <print>
#include <algorithm> // 여기있는 걸 기능을 코딩하면 안된다
#include <fstream>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	std::array<int, 1000> a;

	for (int i = 0; i < 1000; ++i) a[i] = uid(dre);

	// 가장 큰 값을 찾기

	std::cout << "최댓값 - " << *std::max_element(a.begin(), a.end()) << std::endl;

	// [문제] a에 있는 값을 파일 "int 1000개.txt"에 텍스트 그대로 저장하라
	// 화면 출력한 것과 같은 형태로 - 파일을 열었을 때 int값을 사람이 읽을 수 있도록

	std::ofstream out{ "int 1000개.txt"}; //RAII
	int i{ 0 };
	for (int num : a) {
		std::print(out, "{:8}", num);
		if (not(++i % 8))
			out << std::endl;
	}

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오후 12:06:13 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - FILE에 저장하고 읽어오기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <array> // STL sequence container 중 하나
#include <print>
#include <algorithm> // 여기있는 걸 기능을 코딩하면 안된다
#include <fstream>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	std::array<int, 1000> a;

	for (int i = 0; i < 1000; ++i) a[i] = uid(dre);

	// 가장 큰 값을 찾기

	std::cout << "최댓값 - " << *std::max_element(a.begin(), a.end()) << std::endl;

	// [문제] a에 있는 값을 파일 "int 1000개.txt"에 텍스트 그대로 저장하라
	// 화면 출력한 것과 같은 형태로 - 파일을 열었을 때 int값을 사람이 읽을 수 있도록

	std::ofstream out{ "int 1000개.txt"}; //RAII
	int i{ 0 };
	for (int num : a) {
		std::print(out, "{:8}", num);
		if (not(++i % 8))
			out << std::endl;
	}

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오후 12:11:21 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - FILE에 저장하고 읽어오기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <array> // STL sequence container 중 하나
#include <print>
#include <algorithm> // 여기있는 걸 기능을 코딩하면 안된다
#include <fstream>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	std::array<int, 1000> a;

	for (int i = 0; i < 1000; ++i) a[i] = uid(dre);

	// 가장 큰 값을 찾기

	std::cout << "최댓값 - " << *std::max_element(a.begin(), a.end()) << std::endl;

	// [문제] a에 있는 값을 파일 "int 1000개.txt"에 텍스트 그대로 저장하라
	// 화면 출력한 것과 같은 형태로 - 파일을 열었을 때 int값을 사람이 읽을 수 있도록

	std::ofstream out{ "int 1000개.txt"}; //RAII
	int i{ 0 };
	for (int num : a) {
		std::print(out, "{:8}", num);
		if (not(++i % 8))
			out << std::endl;
	}

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오후 12:12:23 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - FILE에 저장하고 읽어오기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <array> // STL sequence container 중 하나
#include <print>
#include <algorithm> // 여기있는 걸 기능을 코딩하면 안된다
#include <fstream>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	std::array<int, 1000> a;

	for (int i = 0; i < 1000; ++i) a[i] = uid(dre);

	// 가장 큰 값을 찾기

	std::cout << "최댓값 - " << *std::max_element(a.begin(), a.end()) << std::endl;

	// [문제] a에 있는 값을 파일 "int 1000개.txt"에 텍스트 그대로 저장하라
	// 화면 출력한 것과 같은 형태로 - 파일을 열었을 때 int값을 사람이 읽을 수 있도록

	std::ofstream out{ "int 1000개.txt"}; //RAII
	int i{ 0 };
	for (int num : a) {
		std::print(out, "{:8}", num);
		if (not(++i % 8))
			out << std::endl;
	}

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오후 12:16:11 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - FILE에 저장하고 읽어오기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <array> // STL sequence container 중 하나
#include <print>
#include <algorithm> // 여기있는 걸 기능을 코딩하면 안된다
#include <fstream>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	std::array<int, 1000> a;

	for (int i = 0; i < 1000; ++i) a[i] = uid(dre);

	// 가장 큰 값을 찾기

	std::cout << "최댓값 - " << *std::max_element(a.begin(), a.end()) << std::endl;

	// [문제] a에 있는 값을 파일 "int 1000개.txt"에 텍스트 그대로 저장하라
	// 화면 출력한 것과 같은 형태로 - 파일을 열었을 때 int값을 사람이 읽을 수 있도록

	std::ofstream out{ "int 1000개.txt"}; //RAII
	int i{ 0 };
	for (int num : a) {
		std::print(out, "{:8}", num);
		if (not(++i % 8))
			out << std::endl;
	}

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-13 오후 12:16:48 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - FILE에 저장하고 읽어오기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <array> // STL sequence container 중 하나
#include <print>
#include <algorithm> // 여기있는 걸 기능을 코딩하면 안된다
#include <fstream>
#include "save.h"
// [문제] 랜덤 int 값 1000개를 생성하여 메모리에 저장하라
// 저장된 값 중에 가장 큰 값을 찾아라
// 찾은 값을 화면에 출력하라. 출력값을 8칸에 맞춰라
// pseudo - 가짜 (알아두자)
// 컴퓨터에서 만들어내는 random 데이터는 수식에 의해 만들기 때문에 예측가능하다

std::default_random_engine dre{ }; // 랜덤 엔진
std::uniform_int_distribution uid{ 0, 999'9999 }; // 엔진의 결과값을 특정 분포로 가공
// uniform 데이터를 쭉 늘어나도록 가공


//--------
int main()
//--------
{
	std::array<int, 1000> a;

	for (int i = 0; i < 1000; ++i) a[i] = uid(dre);

	// 가장 큰 값을 찾기

	std::cout << "최댓값 - " << *std::max_element(a.begin(), a.end()) << std::endl;

	// [문제] a에 있는 값을 파일 "int 1000개.txt"에 텍스트 그대로 저장하라
	// 화면 출력한 것과 같은 형태로 - 파일을 열었을 때 int값을 사람이 읽을 수 있도록

	std::ofstream out{ "int 1000개.txt"}; //RAII
	int i{ 0 };
	for (int num : a) {
		std::print(out, "{:8}", num);
		if (not(++i % 8))
			out << std::endl;
	}

	save("0313.cpp");
}

================================
저장한 시간 : 2025-03-18 오후 4:06:26 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - FILE에 저장하고 읽어오기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include <print>
#include "save.h"
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text mode로 기록되어 있다.
// 메모리로 다 읽어 와라
// 가장 큰 값을 찾아 화면에 출력하라
// 화면에 출력된 큰 값을 답지에 적어라

//--------
int main()
//--------
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> a{};
	std::copy(std::istream_iterator<int>{in}, {}, a.begin());

	std::sort(a.begin(), a.end());

	for (int num : a)
		std::print("{:8}", num);
	std::cout<<std::endl;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)

================================
저장한 시간 : 2025-03-18 오후 4:08:11 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - FILE에 저장하고 읽어오기
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include <print>
#include <ranges>
#include "save.h"
// [문제] 파일 "int 1000개.txt"에는 int값 1000개가 text mode로 기록되어 있다.
// 메모리로 다 읽어 와라
// 가장 큰 값을 찾아 화면에 출력하라
// 화면에 출력된 큰 값을 답지에 적어라

//--------
int main()
//--------
{
	std::ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	std::array<int, 1000> a{};
	std::copy(std::istream_iterator<int>{in}, {}, a.begin());

	std::ranges::sort(a);

	for (int num : a)
		std::print("{:8}", num);
	std::cout<<std::endl;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)

================================
저장한 시간 : 2025-03-18 오후 4:12:11 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"
// [질문] 지난 시간에 int 값 1000개를 저장하였다. 
// 파일에서 사용한 바이트 수를 확인해 본다. - 

//--------
int main()
//--------
{
	
	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)

================================
저장한 시간 : 2025-03-18 오후 4:15:11 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
// [질문] 지난 시간에 int 값 1000개를 저장하였다. 
// 파일에서 사용한 바이트 수를 확인해 본다. - 8250바이트를 사용했다.

//--------
int main()
//--------
{
	std::array<int, 1000> a;
	std::cout << "a가 사용하는 메모리 크기 - " << sizeof a << std::endl;
	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)

================================
저장한 시간 : 2025-03-18 오후 4:18:49 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <bitset>
#include "save.h"
// [질문] 지난 시간에 int 값 1000개를 저장하였다. 
// 파일에서 사용한 바이트 수를 확인해 본다. - 8250바이트를 사용했다.

//--------
int main()
//--------
{
	int num{ 0x01020304 };

	std::bitset<sizeof(int)> bin( num );

	std::cout << " 2진수 - " << bin << std::endl;
	std::cout << "10진수 - " << num << std::endl;
	std::cout << "16진수 - " << std::hex << num << std::endl;;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)

================================
저장한 시간 : 2025-03-18 오후 4:19:30 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <bitset>
#include "save.h"
// [질문] 지난 시간에 int 값 1000개를 저장하였다. 
// 파일에서 사용한 바이트 수를 확인해 본다. - 8250바이트를 사용했다.

//--------
int main()
//--------
{
	int num{ 0x01020304 };

	std::bitset<sizeof(int)> binary( num );

	std::cout << " 2진수 - " << binary << std::endl;
	std::cout << "10진수 - " << num << std::endl;
	std::cout << "16진수 - 0x" << std::hex << num << std::endl;;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)

================================
저장한 시간 : 2025-03-18 오후 4:19:47 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <bitset>
#include "save.h"
// [질문] 지난 시간에 int 값 1000개를 저장하였다. 
// 파일에서 사용한 바이트 수를 확인해 본다. - 8250바이트를 사용했다.

//--------
int main()
//--------
{
	int num{ 0x01020304 };

	std::bitset<sizeof(int)> binary = num;

	std::cout << " 2진수 - " << binary << std::endl;
	std::cout << "10진수 - " << num << std::endl;
	std::cout << "16진수 - 0x" << std::hex << num << std::endl;;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)

================================
저장한 시간 : 2025-03-18 오후 4:20:07 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <bitset>
#include "save.h"
// [질문] 지난 시간에 int 값 1000개를 저장하였다. 
// 파일에서 사용한 바이트 수를 확인해 본다. - 8250바이트를 사용했다.

//--------
int main()
//--------
{
	int num{ 0x01020304 };

	std::bitset<32> binary = num;

	std::cout << " 2진수 - " << binary << std::endl;
	std::cout << "10진수 - " << num << std::endl;
	std::cout << "16진수 - 0x" << std::hex << num << std::endl;;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)

================================
저장한 시간 : 2025-03-18 오후 4:31:14 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "int 천개를 메모리 그대로 기록" };

	std::array<int, 1000> a;

	for (int i{ 0 }; i < 1000; ++i) {
		a[i] = i + 1;
	}

	for (int num : a)
		std::cout << num << " ";
	std::cout << std::endl;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 4:32:34 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "int 천개를 메모리 그대로 기록" };

	std::array<int, 1000> a;

	int i{};
	for (int num : a)
		num = ++i;

	for (int num : a)
		std::cout << num << " ";
	std::cout << std::endl;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 4:33:18 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "int 천개를 메모리 그대로 기록" };

	std::array<int, 1000> a;

	int i{};
	for (int& num : a)
		num = ++i;

	for (int num : a)
		std::cout << num << " ";
	std::cout << std::endl;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 4:35:18 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include <numeric>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "int 천개를 메모리 그대로 기록" };

	std::array<int, 1000> a;

	std::iota(a.begin(), a.end(), 1);

	for (int num : a)
		std::cout << num << " ";
	std::cout << std::endl;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 4:43:11 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include <numeric>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "int 천개를 메모리 그대로 기록" };

	std::array<int, 1000> a;

	std::iota(a.begin(), a.end(), 1);

	// 저수준 함수로 기록한다.
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 4:45:18 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include <numeric>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "int 천개를 메모리 그대로 기록" };

	std::array<int, 1000> a;
	a.fill(32);
	//std::iota(a.begin(), a.end(), 1);

	// 저수준 함수로 기록한다.
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 4:46:09 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include <numeric>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "int 천개를 메모리 그대로 기록" };

	std::array<int, 1000> a;
	a.fill(16);
	//std::iota(a.begin(), a.end(), 1);

	// 저수준 함수로 기록한다.
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 4:46:51 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include <numeric>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "int 천개를 메모리 그대로 기록" };

	std::array<int, 1000> a;
	a.fill(1000);
	//std::iota(a.begin(), a.end(), 1);

	// 저수준 함수로 기록한다.
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 4:47:22 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include <numeric>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "int 천개를 메모리 그대로 기록" };

	std::array<int, 1000> a;
	a.fill(10);
	//std::iota(a.begin(), a.end(), 1);

	// 저수준 함수로 기록한다.
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 4:49:54 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include <numeric>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "int 천개를 메모리 그대로 기록" };

	std::array<int, 1000> a;
	a.fill(16);
	//std::iota(a.begin(), a.end(), 1);

	// 저수준 함수로 기록한다.
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 4:55:21 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include <numeric>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "int 천개를 메모리 그대로 기록",  std::ios::binary};

	std::array<int, 1000> a;
	a.fill(10);
	//std::iota(a.begin(), a.end(), 1);

	// 저수준 함수로 기록한다.
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 4:55:42 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <fstream>
#include <numeric>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "int 천개를 메모리 그대로 기록",  std::ios::binary};

	std::array<int, 1000> a;
	//a.fill(10);
	std::iota(a.begin(), a.end(), 1);

	// 저수준 함수로 기록한다.
	out.write((char*)a.data(), sizeof(int) * a.size());

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 5:00:15 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "진짜 랜덤", std::ios::binary };

	std::random_device rd{};
	for (int i{ 0 }; i < 10; ++i)
		std::cout << rd() << std::endl;;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 5:00:27 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "진짜 랜덤", std::ios::binary };

	std::random_device rd{};
	for (int i{ 0 }; i < 10; ++i)
		std::cout << rd() << std::endl;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 5:02:17 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
// [문제] 1부터 시작하는 int 값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 
// 파일 "int 천개를 메모리 그대로 기록" 에 기록한다.
// -> 메모리에 있는 bit를 그대로 파일에 기록한다.

//--------
int main()
//--------
{
	std::ofstream out{ "진짜 랜덤", std::ios::binary };

	std::random_device rd{};

	int num;
	for (int i{ 0 }; i < 100000; ++i) {
		num = rd();
		out.write((char*) & num, sizeof(int));
	}

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 5:12:10 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// [문제] e-class에서 다운 받은 "진짜 랜덤" 파일에는 int 값 100000개가 있다.
// 파일은 binary mode로 오픈하였고 write 함수를 사용하여 int값을 기록하였다.
// int값 10만개를 메모리로 읽어와라
// 가장 큰 값과 가장 작은 값을 찾아 화면에 출력하라.
// 출력된 값도 답지에 적어라

//--------
int main()
//--------
{
	std::ifstream in{ "진짜 랜덤" };
	if (not in)
		exit(20250318);

	std::array<int, 100000> a;

	//std::copy(std::istream_iterator<int>{}, {}, a);

	//for (int num : a)
		//std::cout << num << std::endl;
		

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-18 오후 5:12:30 화요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// [문제] e-class에서 다운 받은 "진짜 랜덤" 파일에는 int 값 100000개가 있다.
// 파일은 binary mode로 오픈하였고 write 함수를 사용하여 int값을 기록하였다.
// int값 10만개를 메모리로 읽어와라
// 가장 큰 값과 가장 작은 값을 찾아 화면에 출력하라.
// 출력된 값도 답지에 적어라

//--------
int main()
//--------
{
	std::ifstream in{ "진짜 랜덤" };
	if (not in)
		exit(20250318);

	std::array<int, 100000> a;

	std::copy(std::istream_iterator<int>{}, {}, a.data());

	//for (int num : a)
		//std::cout << num << std::endl;
		

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-20 오전 10:32:47 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// [문제] e-class에서 다운 받은 "진짜 랜덤" 파일에는 int 값 100000개가 있다.
// 파일은 binary mode로 오픈하였고 write 함수를 사용하여 int값을 기록하였다.
// int값 10만개를 메모리로 읽어와라
// 가장 큰 값과 가장 작은 값을 찾아 화면에 출력하라.
// 출력된 값도 답지에 적어라

//--------
int main()
//--------
{
	std::ifstream in{ "진짜 랜덤", std::ios::binary };
	if (not in)
		exit(20250318);

	std::array<int, 100000> a;

	std::copy(std::istream_iterator<int>{}, {}, a.data());

	for (int num : a)
		std::cout << num << std::endl;
		

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-20 오전 10:35:27 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// [문제] e-class에서 다운 받은 "진짜 랜덤" 파일에는 int 값 100000개가 있다.
// 파일은 binary mode로 오픈하였고 write 함수를 사용하여 int값을 기록하였다.
// int값 10만개를 메모리로 읽어와라
// 가장 큰 값과 가장 작은 값을 찾아 화면에 출력하라.
// 출력된 값도 답지에 적어라

//--------
int main()
//--------
{
	std::ifstream in{ "진짜 랜덤", std::ios::binary };
	if (not in)
		exit(20250318);

	int num;
	size_t cnt{};
	while (in.read((char*)&num, sizeof(int)))
		++cnt;

	std::cout << "int의 개수 - " << cnt << std::endl;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-20 오전 10:38:56 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// [문제] e-class에서 다운 받은 "진짜 랜덤" 파일에는 int 값 100000개가 있다.
// 파일은 binary mode로 오픈하였고 write 함수를 사용하여 int값을 기록하였다.
// int값 10만개를 메모리로 읽어와라
// 가장 큰 값과 가장 작은 값을 찾아 화면에 출력하라.
// 출력된 값도 답지에 적어라

//--------
int main()
//--------
{
	std::ifstream in{ "진짜 랜덤", std::ios::binary };
	if (not in)
		exit(20250318);

	std::array<int, 100000> a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	std::cout << "가장 큰 값 - " << *std::max_element(a.begin(), a.end()) << std::endl;
	std::cout << "가장 작은 값 - " << *std::min_element(a.begin(), a.end()) << std::endl;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-20 오전 10:43:09 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// [문제] e-class에서 다운 받은 "진짜 랜덤" 파일에는 int 값 100000개가 있다.
// 파일은 binary mode로 오픈하였고 write 함수를 사용하여 int값을 기록하였다.
// int값 10만개를 메모리로 읽어와라
// 가장 큰 값과 가장 작은 값을 찾아 화면에 출력하라.
// 출력된 값도 답지에 적어라

//--------
int main()
//--------
{
	std::ifstream in{ "진짜 랜덤", std::ios::binary };
	if (not in)
		exit(20250318);

	std::array<int, 100000> a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	auto pos = std::minmax_element(a.begin(), a.end());
	std::cout << *pos.first << std::endl;
	std::cout << *pos.second << std::endl;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-20 오전 10:46:38 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// [문제] e-class에서 다운 받은 "진짜 랜덤" 파일에는 int 값 100000개가 있다.
// 파일은 binary mode로 오픈하였고 write 함수를 사용하여 int값을 기록하였다.
// int값 10만개를 메모리로 읽어와라
// 가장 큰 값과 가장 작은 값을 찾아 화면에 출력하라.
// 출력된 값도 답지에 적어라

//--------
int main()
//--------
{
	std::ifstream in{ "진짜 랜덤", std::ios::binary };
	if (not in)
		exit(20250318);

	std::array<int, 100000> a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	auto [minPos, maxPos] = std::minmax_element(a.begin(), a.end()); //std::pair
	// [] structured binding
	std::cout << "최솟값 - " << *minPos << std::endl;
	std::cout << "최댓값 - " << *maxPos << std::endl;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-20 오전 10:59:27 목요일
================================

//------------------------------------------------------------------------
// 2025.03.13 STL 목23											 (2주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
// [문제] e-class에서 다운 받은 "진짜 랜덤" 파일에는 int 값 100000개가 있다.
// 파일은 binary mode로 오픈하였고 write 함수를 사용하여 int값을 기록하였다.
// int값 10만개를 메모리로 읽어와라
// 가장 큰 값과 가장 작은 값을 찾아 화면에 출력하라.
// 출력된 값도 답지에 적어라

//--------
int main()
//--------
{
	std::ifstream in{ "진짜 랜덤", std::ios::binary };
	if (not in)
		exit(20250318);

	std::array<int, 100000> a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	auto [minPos, maxPos] = std::minmax_element(a.begin(), a.end()); //std::pair
	// [] structured binding
	std::cout << "최솟값 - " << *minPos << std::endl;
	std::cout << "최댓값 - " << *maxPos << std::endl;

	save("0318.cpp");
}

// 꼭 외울 것! : 시간의 연속성 (continuous), 공간의 연속성 (contiguous)
// 메모리를 저장할때 뒤에서부터 저장하는 방식  - Little endian

================================
저장한 시간 : 2025-03-20 오전 10:59:53 목요일
================================

//------------------------------------------------------------------------
// 2025.03.20 STL 목23											 (3주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// [문제] 

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {
		id = ++sid;

		for (int i{ 0 }; i < 15; ++i)
			name += uid(dre);
	}
	void show() const {
		std::println("[{:8}] - {}", id, name);
	}
private:
	std::string name;
	int id;

	static int sid; // access - local, life-time - global
};

int Dog::sid{};

//--------
int main()
//--------
{
	for (int i{ 0 }; i < 100; ++i) {
		Dog dog;
		dog.show();
	}
	save("0320.cpp");
}


================================
저장한 시간 : 2025-03-20 오전 11:02:53 목요일
================================

//------------------------------------------------------------------------
// 2025.03.20 STL 목23											 (3주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <print>
#include "save.h"
// [문제] 

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {
		id = ++sid;

		for (int i{ 0 }; i < 15; ++i)
			name += uid(dre);
	}
	void show() const {
		std::println("[{:8}] - {}", id, name);
	}
private:
	std::string name;
	int id;

	static int sid; // access - local, life-time - global
};

int Dog::sid{};

//--------
int main()
//--------
{
	for (int i{ 0 }; i < 100; ++i) {
		Dog dog;
		dog.show();
	}
	save("0320.cpp");
}


================================
저장한 시간 : 2025-03-20 오전 11:11:22 목요일
================================

//------------------------------------------------------------------------
// 2025.03.20 STL 목23											 (3주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// [문제] Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 
// write 함수를 이용하여 메모리 그대로 저장하라.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {
		id = ++sid;

		for (int i{ 0 }; i < 15; ++i)
			name += uid(dre);
	}
	void show() const {
		std::println("[{:8}] - {}", id, name);
	}
private:
	std::string name;
	int id;

	static int sid; // access - local, life-time - global
};

int Dog::sid{};

//--------
int main()
//--------
{
	std::ofstream out{ "Dog 10만마리", std::ios::binary };

	Dog dog;
	for (int i{ 0 }; i < 100000; ++i) {
		out.write((char*)&dog, sizeof(Dog));
	}
	save("0320.cpp");
}


================================
저장한 시간 : 2025-03-20 오전 11:43:22 목요일
================================

//------------------------------------------------------------------------
// 2025.03.20 STL 목23											 (3주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// [문제] Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 
// write 함수를 이용하여 메모리 그대로 저장하라.

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {
		id = ++sid;

		for (int i{ 0 }; i < 15; ++i)
			name += uid(dre);
	}
	void show() const {
		std::println("[{:8}] - {}", id, name);
	}
private:
	std::string name;
	int id;

	static int sid; // access - local, life-time - global
};

int Dog::sid{};

//--------
int main()
//--------
{
	std::ofstream out{ "Dog 10만마리", std::ios::binary };

	for (int i{ 0 }; i < 100000; ++i) {
		Dog dog;
		out.write((char*)&dog, sizeof(Dog));
	}
	save("0320.cpp");
}

================================
저장한 시간 : 2025-03-20 오전 11:44:21 목요일
================================

//------------------------------------------------------------------------
// 2025.03.20 STL 목23											 (3주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 객체를 
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"

class Dog {
private:
	std::string name;
	int id;

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << "\t" << dog.name;
	}
};

// [문제] Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 파일의 write함수를 사용하여 객체 메모리 전체를 그대로 저장하였다.
// 파일을 있는 객체 전체를 메모리로 읽어와라.
// name과 id를 화면에 출력하라

std::array<Dog, 100000> dogs;

//--------
int main()
//--------
{
	std::ifstream in{ "Dog 10만마리" , std::ios::binary };
	if (not in)
		exit(20250320);

	in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));

	for (const Dog& dog : dogs)
		std::cout << dog << std::endl;

	save("0320.cpp");
}


================================
저장한 시간 : 2025-03-20 오전 11:44:44 목요일
================================

//------------------------------------------------------------------------
// 2025.03.20 STL 목23											 (3주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 객체를 
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"

class Dog {
private:
	std::string name;
	int id;

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << "\t" << dog.name;
	}
};

// [문제] Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 파일의 write함수를 사용하여 객체 메모리 전체를 그대로 저장하였다.
// 파일을 있는 객체 전체를 메모리로 읽어와라.
// name과 id를 화면에 출력하라

std::array<Dog, 100000> dogs;

//--------
int main()
//--------
{
	std::ifstream in{ "Dog 10만마리" , std::ios::binary };
	if (not in)
		exit(20250320);

	in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));

	for (const Dog& dog : dogs)
		std::cout << dog << std::endl;

	save("0320.cpp");
}


================================
저장한 시간 : 2025-03-20 오전 11:50:56 목요일
================================

//------------------------------------------------------------------------
// 2025.03.20 STL 목23											 (3주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// [문제] Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 
// 출력 연산자 << 를 사용하여 저장하였다.
// 함수는 다음과 같다.
//	friend std::ostream& operator<<(std::ostream& os, Dog& dog) {
//		os.write((char*)&dog, sizeof(Dog));
//		return os;
//	}

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {
		id = ++sid;

		for (int i{ 0 }; i < 15; ++i)
			name += uid(dre);
	}
	void show() const {
		std::println("[{:8}] - {}", id, name);
	}
private:
	std::string name;
	int id;

	static int sid; // access - local, life-time - global

	friend std::ostream& operator<<(std::ostream& os, Dog& dog) {
		os.write((char*)&dog, sizeof(Dog));
		return os;
	}
};

int Dog::sid{};

//--------
int main()
//--------
{
	std::ofstream out{ "Dog 10만마리", std::ios::binary };

	for (int i{ 0 }; i < 100000; ++i) {
		Dog dog;
		out << dog;
	}
	save("0320.cpp");
}

================================
저장한 시간 : 2025-03-20 오전 11:51:34 목요일
================================

//------------------------------------------------------------------------
// 2025.03.20 STL 목23											 (3주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include <print>
#include <fstream>
#include "save.h"
// [문제] Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 
// 출력 연산자 << 를 사용하여 저장하였다.
// 함수는 다음과 같다.
//	friend std::ostream& operator<<(std::ostream& os, Dog& dog) {
//		os.write((char*)&dog, sizeof(Dog));
//		return os;
//	}

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

class Dog {
public:
	Dog() {
		id = ++sid;

		for (int i{ 0 }; i < 15; ++i)
			name += uid(dre);
	}
	void show() const {
		std::println("[{:8}] - {}", id, name);
	}
private:
	std::string name;
	int id;

	static int sid; // access - local, life-time - global

	friend std::ostream& operator<<(std::ostream& os, Dog& dog) {
		os.write((char*)&dog, sizeof(Dog));
		return os;
	}
};

int Dog::sid{};

//--------
int main()
//--------
{
	std::ofstream out{ "Dog 10만마리", std::ios::binary };

	for (int i{ 0 }; i < 100000; ++i) {
		Dog dog;
		out << dog;
	}
	save("0320.cpp");
}

================================
저장한 시간 : 2025-03-20 오후 12:02:04 목요일
================================

//------------------------------------------------------------------------
// 2025.03.20 STL 목23											 (3주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 객체를 
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"

class Dog {
private:
	std::string name;
	int id;

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << "\t" << dog.name;
	}

	friend std::istream& operator>>(std::istream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

// [문제] Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 출력 연산자 << 를 사용하여 저장하였다.
// 함수는 다음과 같다.
//	friend std::ostream& operator<<(std::ostream& os, Dog& dog) {
//		os.write((char*)&dog, sizeof(Dog));
//		return os;
//	}


std::array<Dog, 100000> dogs;

//--------
int main()
//--------
{
	std::ifstream in{ "Dog 10만마리" , std::ios::binary };
	if (not in)
		exit(20250320);

	// [문제] 다음 코드가 실행되게 하라.
	Dog dog;
	for (int i{ 0 }; i < 10; ++i) {
		in >> dog;
		std::cout << dog << std::endl;
	}

	save("0320.cpp");
}


================================
저장한 시간 : 2025-03-20 오후 12:06:16 목요일
================================

//------------------------------------------------------------------------
// 2025.03.20 STL 목23											 (3주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 객체를 
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"

class Dog {
private:
	std::string name;
	int id;

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << "\t" << dog.name;
	}

	friend std::istream& operator>>(std::istream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

// [문제] Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 출력 연산자 << 를 사용하여 저장하였다.
// 함수는 다음과 같다.
//	friend std::ostream& operator<<(std::ostream& os, Dog& dog) {
//		os.write((char*)&dog, sizeof(Dog));
//		return os;
//	}


std::array<Dog, 100000> dogs;

//--------
int main()
//--------
{
	std::ifstream in{ "Dog 10만마리" , std::ios::binary };
	if (not in)
		exit(20250320);

	// [문제] 한 번에 메모리에 읽어온다.
	
	in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));

	for (const Dog& dog : dogs)
		std::cout << dog << std::endl;
	
	save("0320.cpp");
}


================================
저장한 시간 : 2025-03-20 오후 12:13:20 목요일
================================

//------------------------------------------------------------------------
// 2025.03.20 STL 목23											 (3주 2일)
//------------------------------------------------------------------------
// 강의 소개 / 많은 개수 자료를 처리하기 - 파일 입출력
//										 - 객체를 
//										 - 바이너리 모드와 저수준 입출력
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include "save.h"

class Dog {
private:
	std::string name;
	int id;

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << "\t" << dog.name;
	}

	friend std::istream& operator>>(std::istream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

// [문제] Dog 객체 10만개를 binary 모드로 연 파일 "Dog 10만마리"에 저장하였다.
// 출력 연산자 << 를 사용하여 저장하였다.
// 함수는 다음과 같다.
//	friend std::ostream& operator<<(std::ostream& os, Dog& dog) {
//		os.write((char*)&dog, sizeof(Dog));
//		return os;
//	}


std::array<Dog, 100000> dogs;

//--------
int main()
//--------
{
	std::ifstream in{ "Dog 10만마리" , std::ios::binary };
	if (not in)
		exit(20250320);

	// [문제] 한 번에 메모리에 읽어온다.
	
	in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));

	for (const Dog& dog : dogs)
		std::cout << dog << std::endl;
	
	save("0320.cpp");
}


// open mode
// low-level의 속도가 굉장히 빠르다
// binary -> high-level ( >>, << )
// text -> low-level (read(), write())

================================
저장한 시간 : 2025-03-25 오후 3:35:23 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"


//--------
int main()
//--------
{
	save("0325.cpp");

	// [문제] 양의 정수 num(int의 max값까진 받자)를 입력받아라.
	// num개 만큼 int를 저장할 메모리를 확보하라
	// 메모리의 내용을 1부터 시작하는 정수로 채워라.
	// 메모리에 저장한 int의 합계를 출력하라.
	// 이 과정을 영원히 반복하라

	while (true) {
		std::cout << "값을 입력하세요 : ";
		int num;
		std::cin >> num;
		std::cout << "1부터 " << num << " 까지 합계입니다 - " << std::endl;
	}
}


================================
저장한 시간 : 2025-03-25 오후 3:36:32 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"


//--------
int main()
//--------
{
	save("0325.cpp");

	// [문제] 양의 정수 num(int의 max값까진 받자)를 입력받아라.
	// num개 만큼 int를 저장할 메모리를 확보하라
	// 메모리의 내용을 1부터 시작하는 정수로 채워라.
	// 메모리에 저장한 int의 합계를 출력하라.
	// 이 과정을 영원히 반복하라

	while (true) {
		std::cout << "값을 입력하세요 : ";
		int num;
		std::cin >> num;

		int sum{ 0 };
		for (int i{ 1 }; i <= num; ++i) sum += i;

		std::cout << "1부터 " << num << " 까지 합계입니다 - " << sum << std::endl;
	}
}


================================
저장한 시간 : 2025-03-25 오후 3:44:16 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"


//--------
int main()
//--------
{
	save("0325.cpp");

	// [문제] 양의 정수 num(int의 max값까진 받자)를 입력받아라.
	// num개 만큼 int를 저장할 메모리를 확보하라
	// 메모리의 내용을 1부터 시작하는 정수로 채워라.
	// 메모리에 저장한 int의 합계를 출력하라.
	// 이 과정을 영원히 반복하라

	while (true) {
		std::cout << "값을 입력하세요 : ";
		int num;
		std::cin >> num;

		int* arr = new int[num];

		for (int i = 0; i < num; ++i)
			arr[i] = i + 1;

		int sum{ 0 };
		for (int i = 0; i < num; ++i)
			sum += arr[i];

		std::cout << "1부터 " << num << " 까지 합계입니다 - " << sum << std::endl;
	}
}


================================
저장한 시간 : 2025-03-25 오후 3:48:22 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"


//--------
int main()
//--------
{
	save("0325.cpp");

	// [문제] 양의 정수 num(int의 max값까진 받자)를 입력받아라.
	// num개 만큼 int를 저장할 메모리를 확보하라
	// 메모리의 내용을 1부터 시작하는 정수로 채워라.
	// 메모리에 저장한 int의 합계를 출력하라.
	// 이 과정을 영원히 반복하라

	while (true) {
		std::cout << "값을 입력하세요 : ";
		int num;
		std::cin >> num;

		int* p = new int[num]; // free-store, HEAP(x)

		for (int i = 0; i < num; ++i)
			p[i] = i + 1;

		int sum{ 0 };
		for (int i = 0; i < num; ++i)
			sum += p[i];

		std::cout << "1부터 " << num << " 까지 합계입니다 - " << sum << std::endl;
	}
}


================================
저장한 시간 : 2025-03-25 오후 3:54:20 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"


//--------
int main()
//--------
{
	save("0325.cpp");

	// [문제] 양의 정수 num(int의 max값까진 받자)를 입력받아라.
	// num개 만큼 int를 저장할 메모리를 확보하라
	// 메모리의 내용을 1부터 시작하는 정수로 채워라.
	// 메모리에 저장한 int의 합계를 출력하라.
	// 이 과정을 영원히 반복하라

	while (true) {
		std::cout << "값을 입력하세요 : ";
		int num;
		std::cin >> num;

		int* p = new int[num]; // free-store, HEAP(x)
		std::iota(p, p + num, 1);

		long long sum{ };
		for (int i = 0; i < num; ++i)
			sum += p[i];

		std::cout << "1부터 " << num << " 까지 합계입니다 - " << sum << std::endl;
	}
}


================================
저장한 시간 : 2025-03-25 오후 3:55:00 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"


//--------
int main()
//--------
{
	save("0325.cpp");

	// [문제] 양의 정수 num(int의 max값까진 받자)를 입력받아라.
	// num개 만큼 int를 저장할 메모리를 확보하라
	// 메모리의 내용을 1부터 시작하는 정수로 채워라.
	// 메모리에 저장한 int의 합계를 출력하라.
	// 이 과정을 영원히 반복하라

	while (true) {
		std::cout << "값을 입력하세요 : ";
		int num;
		std::cin >> num;

		int* p = new int[num]; // free-store, HEAP(x)
		std::iota(p, p + num, 1);

		long long sum{ };
		for (int i = 0; i < num; ++i)
			sum += p[i];

		std::cout << "1부터 " << num << " 까지 합계입니다 - " << sum << std::endl;
	}
}


================================
저장한 시간 : 2025-03-25 오후 3:55:31 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"


//--------
int main()
//--------
{
	save("0325.cpp");

	// [문제] 양의 정수 num(int의 max값까진 받자)를 입력받아라.
	// num개 만큼 int를 저장할 메모리를 확보하라
	// 메모리의 내용을 1부터 시작하는 정수로 채워라.
	// 메모리에 저장한 int의 합계를 출력하라.
	// 이 과정을 영원히 반복하라

	while (true) {
		std::cout << "값을 입력하세요 : ";
		int num;
		std::cin >> num;

		int* p = new int[num]; // free-store, HEAP(x)
		std::iota(p, p + num, 1);

		long long sum{ };
		for (int i = 0; i < num; ++i)
			sum += p[i];

		std::cout << "1부터 " << num << " 까지 합계입니다 - " << sum << std::endl;
	}
}


================================
저장한 시간 : 2025-03-25 오후 4:04:43 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"


//--------
int main()
//--------
{
	save("0325.cpp");

	// [문제] 양의 정수 num(int의 max값까진 받자)를 입력받아라.
	// num개 만큼 int를 저장할 메모리를 확보하라
	// 메모리의 내용을 1부터 시작하는 정수로 채워라.
	// 메모리에 저장한 int의 합계를 출력하라.
	// 이 과정을 영원히 반복하라

	while (true) {
		std::cout << "값을 입력하세요 : ";
		int num;
		std::cin >> num;

		int* p; // free-store, HEAP(x)
		

		try {
			p = new int[num];
		}
		catch (const std::exception& e) {
			std::cout << e.what() << std::endl;
			return 20250325;
		}

		std::iota(p, p + num, 1);
		
		long long sum = std::accumulate(p, p + num, 0);

		std::cout << "1부터 " << num << " 까지 합계입니다 - " << sum << std::endl;

		delete[] p;
	}
}


================================
저장한 시간 : 2025-03-25 오후 4:05:53 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"


//--------
int main()
//--------
{
	save("0325.cpp");

	// [문제] 양의 정수 num(int의 max값까진 받자)를 입력받아라.
	// num개 만큼 int를 저장할 메모리를 확보하라
	// 메모리의 내용을 1부터 시작하는 정수로 채워라.
	// 메모리에 저장한 int의 합계를 출력하라.
	// 이 과정을 영원히 반복하라

	while (true) {
		std::cout << "값을 입력하세요 : ";
		int num;
		std::cin >> num;

		int* p; // free-store, HEAP(x)
		

		try {
			p = new int[num];
		}
		catch (const std::exception& e) {
			std::cout << e.what() << std::endl;
			return 20250325;
		}

		std::iota(p, p + num, 1);
		
		auto sum = std::accumulate(p, p + num, 0);

		std::cout << "1부터 " << num << " 까지 합계입니다 - " << sum << std::endl;

		delete[] p;
	}
}


================================
저장한 시간 : 2025-03-25 오후 4:06:48 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"


//--------
int main()
//--------
{
	save("0325.cpp");

	// [문제] 양의 정수 num(int의 max값까진 받자)를 입력받아라.
	// num개 만큼 int를 저장할 메모리를 확보하라
	// 메모리의 내용을 1부터 시작하는 정수로 채워라.
	// 메모리에 저장한 int의 합계를 출력하라.
	// 이 과정을 영원히 반복하라

	while (true) {
		std::cout << "값을 입력하세요 : ";
		int num;
		std::cin >> num;

		int* p; // free-store, HEAP(x)
		

		try {
			p = new int[num];
		}
		catch (const std::exception& e) {
			std::cout << e.what() << std::endl;
			return 20250325;
		}

		std::iota(p, p + num, 1);
		
		long long sum = std::accumulate(p, p + num, 0LL);

		std::cout << "1부터 " << num << " 까지 합계입니다 - " << sum << std::endl;

		delete[] p;
	}
}


================================
저장한 시간 : 2025-03-25 오후 4:16:58 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"

void f()
{
	int* p;
	p = new int[10];

	std::cout << "번지 - " << p << " - ";
	for (int i = 0; i < 10; ++i)
		std::cout << p[i] << " " << std::endl;

	delete[] p;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	f();
}


================================
저장한 시간 : 2025-03-25 오후 4:17:30 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"

void f()
{
	int* p;
	p = new int[10];

	std::cout << "번지 - " << p << " - ";
	for (int i = 0; i < 10; ++i)
		std::cout << p[i] << " ";

	std::cout << std::endl;

	delete[] p;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	f();
}


================================
저장한 시간 : 2025-03-25 오후 4:18:09 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"

void f()
{
	int* p;
	p = new int[10];

	std::cout << "번지 - " << p << " - ";
	for (int i = 0; i < 10; ++i)
		std::cout << p[i] << " ";

	std::cout << std::endl;

	delete[] p;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	f();
}


================================
저장한 시간 : 2025-03-25 오후 4:18:34 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"

void f()
{
	int* p;
	p = new int[10];

	std::cout << "번지 - " << p << " - ";
	for (int i = 0; i < 10; ++i)
		std::cout << p[i] << " ";

	std::cout << std::endl;

	delete[] p;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	for (int i = 0; i < 10; ++i) {
		f();
	}
}


================================
저장한 시간 : 2025-03-25 오후 4:19:41 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"

void f()
{
	int* p;
	p = new int[10] { };

	std::cout << "번지 - " << p << " - ";
	for (int i = 0; i < 10; ++i)
		std::cout << p[i] << " ";

	std::cout << std::endl;

	delete[] p;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	for (int i = 0; i < 10; ++i) {
		f();
	}
}


================================
저장한 시간 : 2025-03-25 오후 4:21:19 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"

void f()
{
	int* p;
	p = new int[10] { };

	// 예외 발생4
	throw 20250325;

	std::cout << "이 문장이 출력될 일은 전혀 없다.";

	delete[] p;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	f();
}


================================
저장한 시간 : 2025-03-25 오후 4:21:59 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"

void f()
{
	int* p;
	p = new int[10] { };

	// 예외 발생
	throw 20250325;

	std::cout << "이 문장이 출력될 일은 전혀 없다." << std::endl;

	delete[] p;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	f();
}


================================
저장한 시간 : 2025-03-25 오후 4:22:46 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"

void f()
{
	int* p;
	p = new int[10] { };

	// 예외 발생
	throw 20250325;

	std::cout << "이 문장이 출력될 일은 전혀 없다." << std::endl;

	delete[] p;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	f();

	std::cout << "메인은 잘 끝날까?" << std::endl;
}


================================
저장한 시간 : 2025-03-25 오후 4:24:00 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"

void f()
{
	int* p;
	p = new int[10] { };

	// 예외 발생
	throw 20250325;

	std::cout << "이 문장이 출력될 일은 전혀 없다." << std::endl;

	delete[] p;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	try {
		f();
	}
	catch (...) {

	}

	std::cout << "메인은 잘 끝날까?" << std::endl;
}


================================
저장한 시간 : 2025-03-25 오후 4:31:58 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"

class Dog {

};

class 스마트 {
public:
	스마트(Dog* p) { }
	~스마트() {
		std::cout << "예외가 발생하더라도 지역객체는 반드시 소멸됨을 보장한다.(stack-unwinding)" << std::endl;
	}
};

void f()
{
	스마트 p { new Dog };
	// 예외 발생
	throw 20250325;

	std::cout << "이 문장이 출력될 일은 전혀 없다." << std::endl;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	try {
		f();
	}
	catch (...) {

	}

	std::cout << "메인은 잘 끝날까?" << std::endl;
}


================================
저장한 시간 : 2025-03-25 오후 4:40:11 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"

class Dog {
public:
	Dog() { std::cout << "멍" << std::endl; }
	~Dog() { std::cout << "꽥.." << std::endl; }
};

class 스마트 {
	Dog* p;
public:
	스마트(Dog* p) : p{ p } { } // RAII : 자원의 생명주기를 객체의 생명주기와 일치시켜주는 행동
	~스마트() {
		delete p;
	}
};

void f()
{
	스마트 p { new Dog };

	// 예외 발생
	throw 20250325;

	std::cout << "이 문장이 출력될 일은 전혀 없다." << std::endl;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	try {
		f();
	}
	catch (...) {

	}

	std::cout << "메인은 잘 끝날까?" << std::endl;
}


================================
저장한 시간 : 2025-03-25 오후 4:40:42 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"

class Dog {
public:
	Dog() { std::cout << "멍" << std::endl; }
	~Dog() { std::cout << "꽥.." << std::endl; }
};

class 스마트 {
	Dog* p;
public:
	스마트(Dog* p) : p{ p } { } // RAII : 자원의 생명주기를 객체의 생명주기와 일치시켜주는 행동
	~스마트() {
		delete p;
	}
};

void f()
{
	스마트 p { new Dog };

	std::cout << "이 문장이 출력될 일은 전혀 없다." << std::endl;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	try {
		f();
	}
	catch (...) {

	}

	std::cout << "메인은 잘 끝날까?" << std::endl;
}


================================
저장한 시간 : 2025-03-25 오후 4:42:34 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <memory>
#include "save.h"

class Dog {
public:
	Dog() { std::cout << "멍" << std::endl; }
	~Dog() { std::cout << "꽥.." << std::endl; }
};

void f()
{
	std::unique_ptr<Dog> p { new Dog };

	std::cout << "이 문장이 출력될 일은 전혀 없다." << std::endl;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	try {
		f();
	}
	catch (...) {

	}

	std::cout << "메인은 잘 끝날까?" << std::endl;
}


================================
저장한 시간 : 2025-03-25 오후 4:43:01 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <memory>
#include "save.h"

class Dog {
public:
	Dog() { std::cout << "멍" << std::endl; }
	~Dog() { std::cout << "꽥.." << std::endl; }
};

void f()
{
	std::unique_ptr<Dog> p { new Dog };

	throw 1;

	std::cout << "이 문장이 출력될 일은 전혀 없다." << std::endl;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	try {
		f();
	}
	catch (...) {

	}

	std::cout << "메인은 잘 끝날까?" << std::endl;
}


================================
저장한 시간 : 2025-03-25 오후 4:46:00 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include <memory>
#include "save.h"

class Dog {
public:
	Dog() { std::cout << "멍" << std::endl; }
	~Dog() { std::cout << "꽥.." << std::endl; }
};

void f()
{
	std::unique_ptr<Dog[]> p = std::make_unique<Dog[]>(3);

	throw 1;

	std::cout << "이 문장이 출력될 일은 전혀 없다." << std::endl;
}

//--------
int main()
//--------
{
	save("0325.cpp");

	try {
		f();
	}
	catch (...) {

	}

	std::cout << "메인은 잘 끝날까?" << std::endl;
}


================================
저장한 시간 : 2025-03-25 오후 4:58:25 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터 - RAII
// RAII - 자원의 생명 주기를 객체의 생명주기와 일치시키는 프로그래밍 기법
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <filesystem>
#include <algorithm>
#include "save.h"


//--------
int main()
//--------
{
	// [문제] "0325.cpp"에 있는 소문자를 모두 대문자로 바꿔 "0325 대문자.cpp"에 저장하라
	std::ifstream in{ "0325.cpp" };
	std::ofstream out{ "0325 대문자.cpp", std::ios::app };

	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });

	save("0325.cpp");
}


================================
저장한 시간 : 2025-03-25 오후 5:05:43 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터 - RAII
// RAII - 자원의 생명 주기를 객체의 생명주기와 일치시키는 프로그래밍 기법
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"


//--------
int main()
//--------
{
	// [문제] "0325.cpp"에 있는 소문자를 모두 대문자로 바꿔 "0325 대문자.cpp"에 저장하라
	std::ifstream in{ "0325.cpp" };
	if (not in)
		return 20250325;

	std::ofstream out{ "0325 대문자.cpp" };

	char c;
	while (in >> c) {
		if (std::islower(c))
			c = toupper(c);
		out << c;
	}

	save("0325.cpp");
}


================================
저장한 시간 : 2025-03-25 오후 5:07:37 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터 - RAII
// RAII - 자원의 생명 주기를 객체의 생명주기와 일치시키는 프로그래밍 기법
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"


//--------
int main()
//--------
{
	// [문제] "0325.cpp"에 있는 소문자를 모두 대문자로 바꿔 "0325 대문자.cpp"에 저장하라
	std::ifstream in{ "0325.cpp" };
	if (not in)
		return 20250325;

	std::ofstream out{ "0325 대문자.cpp" };

	char c;
	in >> std::noskipws;
	while (in >> c) {
		c = toupper(c);
		out << c;
	}

	save("0325.cpp");
}


================================
저장한 시간 : 2025-03-25 오후 5:13:13 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터 - RAII
// RAII - 자원의 생명 주기를 객체의 생명주기와 일치시키는 프로그래밍 기법
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"


//--------
int main()
//--------
{
	// [문제] "0325.cpp"에 있는 소문자를 모두 대문자로 바꿔 "0325 대문자.cpp"에 저장하라
	std::ifstream in{ "0325.cpp" };
	if (not in)
		return 20250325;
	std::ofstream out{ "0325 대문자.cpp" };

	std::transform(std::istream_iterator<char>{in}, {},
		std::ostream_iterator<char>{std::cout}, [](char c) {return toupper(c); });

	save("0325.cpp");
}


================================
저장한 시간 : 2025-03-25 오후 5:13:56 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// 강의 소개 / 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// 동적할당(real_time)과 스마트포인터 - RAII
// RAII - 자원의 생명 주기를 객체의 생명주기와 일치시키는 프로그래밍 기법
// OS가 구분한다. - 
// 1. STACK
// 2. DATA
// 3. free-store(HEAP)
// 
// 1, 2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을때
// 1과 2의 구분 - 1의 한계(default 1M 바이트)를 초과하면 2를 사용한다.
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"


//--------
int main()
//--------
{
	// [문제] "0325.cpp"에 있는 소문자를 모두 대문자로 바꿔 "0325 대문자.cpp"에 저장하라
	std::ifstream in{ "0325.cpp" };
	if (not in)
		return 20250325;
	std::ofstream out{ "0325 대문자.cpp" };

	std::transform(std::istream_iterator<char>{in}, {},
		std::ostream_iterator<char>{std::cout}, [ ](char c) {return toupper(c);});

	save("0325.cpp");
}


================================
저장한 시간 : 2025-03-27 오전 10:35:09 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable type
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// qsort를 이용하여 오름차순으로 정렬하라
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre{};
std::uniform_int_distribution uid{ };

//--------
int main()
//--------
{
	std::array<int, 10000000> a;

	for (int i = 0; i < 10000000; ++i) a[i] = uid(dre);
	

	save("0327.cpp");
}


================================
저장한 시간 : 2025-03-27 오전 10:53:59 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable type
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// qsort를 이용하여 오름차순으로 정렬하라
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid;


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

int 기준(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p > *q)
		return 1;
	else if (*p < *q)
		return -1;
	return 0;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );

	std::qsort(a.data(), NUM, sizeof(std::array<int, NUM>::value_type), 기준);
	
	for (int i = 0; i < 1000; ++i)
		std::cout << a[i] << std::endl;

	save("0327.cpp");
}

================================
저장한 시간 : 2025-03-27 오전 10:54:45 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable type
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// qsort를 이용하여 오름차순으로 정렬하라
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

int 기준(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p > *q)
		return 1;
	else if (*p < *q)
		return -1;
	return 0;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );

	std::qsort(a.data(), NUM, sizeof(std::array<int, NUM>::value_type), 기준);
	
	for (int i = 0; i < 1000; ++i)
		std::cout << a[i] << std::endl;

	save("0327.cpp");
}

================================
저장한 시간 : 2025-03-27 오전 10:56:01 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable type
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// qsort를 이용하여 오름차순으로 정렬하라
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

int 기준(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p > *q)
		return 1;
	else if (*p < *q)
		return -1;
	return 0;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );

	std::qsort(a.data(), NUM, sizeof(std::array<int, NUM>::value_type), 기준);
	
	for (int i = 0; i < 1000; ++i)
		std::print("{:8}", a[i]);

	save("0327.cpp");
}

================================
저장한 시간 : 2025-03-27 오전 10:56:20 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable type
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// qsort를 이용하여 오름차순으로 정렬하라
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

int 기준(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p > *q)
		return 1;
	else if (*p < *q)
		return -1;
	return 0;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );

	std::qsort(a.data(), NUM, sizeof(std::array<int, NUM>::value_type), 기준);
	
	for (int i = 0; i < 1000; ++i)
		std::print("{:8}", a[i]);
	std::cout << std::endl;

	save("0327.cpp");
}

================================
저장한 시간 : 2025-03-27 오전 10:59:32 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable type
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// qsort를 이용하여 오름차순으로 정렬하라
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

int 기준(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p > *q)
		return 1;
	else if (*p < *q)
		return -1;
	return 0;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );

	std::qsort(a.data(), NUM, sizeof(std::array<int, NUM>::value_type), 기준);
	
	for (int num : a | std::views::take(100))
		std::print("{:8}", num);
	std::cout << std::endl;

	save("0327.cpp");
}

================================
저장한 시간 : 2025-03-27 오전 11:13:18 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable type
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// qsort를 이용하여 오름차순으로 정렬하라
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p > *q)
		return 1;
	else if (*p < *q)
		return -1;
	return 0;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );

	int(*정렬기준)(const void*, const void*) = 오름차순;

	std::qsort(a.data(), NUM, sizeof(std::array<int, NUM>::value_type), 정렬기준);
	
	for (int num : a | std::views::take(1000))
		std::print("{:8}", num);
	std::cout << std::endl;

	save("0327.cpp");
}

// std::views::takes : 거르는 기능

================================
저장한 시간 : 2025-03-27 오전 11:14:36 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable type
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// qsort를 이용하여 오름차순으로 정렬하라
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p > *q)
		return 1;
	else if (*p < *q)
		return -1;
	return 0;
}
int 내림차순(const void* a, const void* b)
{
	int* p = (int*)a;
	int* q = (int*)b;

	if (*p > *q)
		return -1;
	else if (*p < *q)
		return 1;
	return 0;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );

	int(*정렬기준)(const void*, const void*) = 오름차순;
	정렬기준 = 내림차순;

	std::qsort(a.data(), NUM, sizeof(std::array<int, NUM>::value_type), 정렬기준);
	
	for (int num : a | std::views::take(1000))
		std::print("{:8}", num);
	std::cout << std::endl;

	save("0327.cpp");
}

// std::views::takes : 거르는 기능

================================
저장한 시간 : 2025-03-27 오전 11:44:17 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );
	bool(*정렬기준)(int, int) = 오름차순;
	std::sort(a.begin(), a.end(), 정렬기준);

	for (int i = 0; i < 100; ++i)
		std::cout << a[i] << std::endl;

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오전 11:44:32 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );
	bool(*정렬기준)(int, int) = 내림차순;
	std::sort(a.begin(), a.end(), 정렬기준);

	for (int i = 0; i < 100; ++i)
		std::cout << a[i] << std::endl;

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오전 11:45:17 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );
	bool(*정렬기준)(int, int) = 내림차순;
	std::ranges::sort(a, 정렬기준);

	for (int i = 0; i < 100; ++i)
		std::cout << a[i] << std::endl;

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오전 11:49:27 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );

	// 스톱워치 시작
	auto b = std::chrono::high_resolution_clock::now();
	std::sort(a.begin(), a.end(), 오름차순);
	auto e = std::chrono::high_resolution_clock::now();
	// 스톱워치 끝

	std::cout << "걸린 시간 - " << e - b << std::endl;

	for (int i = 0; i < 100; ++i)
		std::cout << a[i] << std::endl;

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오전 11:49:48 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );

	// 스톱워치 시작
	auto b = std::chrono::high_resolution_clock::now();
	std::sort(a.begin(), a.end(), 오름차순);
	auto e = std::chrono::high_resolution_clock::now();
	// 스톱워치 끝

	std::cout << "걸린 시간 - " << e - b << std::endl;

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오전 11:50:28 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );

	// 스톱워치 시작
	auto b = std::chrono::high_resolution_clock::now();
	std::sort(a.begin(), a.end(), 오름차순);
	auto e = std::chrono::high_resolution_clock::now();
	// 스톱워치 끝

	std::cout << "걸린 시간 - " << e - b << std::endl;

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오전 11:52:20 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	for (int& num : a)
		num = uid( dre );

	// 스톱워치 시작
	auto b = std::chrono::high_resolution_clock::now();
	std::sort(a.begin(), a.end(), 오름차순);
	auto e = std::chrono::high_resolution_clock::now();
	// 스톱워치 끝

	std::cout << "걸린 시간 - " << e - b << std::endl;
	std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl; 

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오전 11:54:08 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), 오름차순);
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
		std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl;
	}

	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), [](int a, int b) {
			return a < b;
			});
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
		std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl;
	}

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오전 11:54:26 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), 오름차순);
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
		std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl;
	}

	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), [](int a, int b) {
			return a < b;
			});
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
		std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl;
	}

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오전 11:54:30 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), 오름차순);
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
		std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl;
	}

	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), [](int a, int b) {
			return a < b;
			});
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
		std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl;
	}

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오전 11:55:37 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), 오름차순);
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
		std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl;
	}

	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), [](int a, int b) {
			return a < b;
			});
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
		std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl;
	}

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오전 11:55:41 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), 오름차순);
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
		std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl;
	}

	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), [](int a, int b) {
			return a < b;
			});
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
		std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl;
	}

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오전 11:55:45 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), 오름차순);
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
		std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl;
	}

	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), [](int a, int b) {
			return a < b;
			});
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
		std::cout << "걸린 시간(초) - " << std::chrono::duration_cast<std::chrono::seconds>(e - b) << std::endl;
	}

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오후 12:05:00 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	std::cout << typeid([]() {
		std::cout << "람다" << std::endl;
		}).name() << std::endl;

	//{
	//	for (int& num : a)
	//		num = uid(dre);

	//	// 스톱워치 시작
	//	auto b = std::chrono::high_resolution_clock::now();
	//	std::sort(a.begin(), a.end(), 오름차순);
	//	auto e = std::chrono::high_resolution_clock::now();
	//	// 스톱워치 끝

	//	std::cout << "걸린 시간 - " << e - b << std::endl;
	//}

	//{
	//	for (int& num : a)
	//		num = uid(dre);

	//	// 스톱워치 시작
	//	auto b = std::chrono::high_resolution_clock::now();
	//	std::sort(a.begin(), a.end(), [](int a, int b) {
	//		return a < b;
	//		});
	//	auto e = std::chrono::high_resolution_clock::now();
	//	// 스톱워치 끝

	//	std::cout << "걸린 시간 - " << e - b << std::endl;
	//}

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-03-27 오후 12:09:10 목요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	auto 람다 = []() {
		std::cout << "람다" << std::endl;
		};

	std::cout << "람다의 정체" << std::endl;
	std::cout << "람다의 크기 - " << sizeof(람다) << std::endl;
	std::cout << "람다의 위치 - " << std::addressof(람다) << std::endl;
	std::cout << "람다의 타입 - " << typeid(람다).name() << std::endl;

	std::cout << std::endl;

	std::cout << "main의 위치 - " << std::addressof(main) << std::endl;
	//{
	//	for (int& num : a)
	//		num = uid(dre);

	//	// 스톱워치 시작
	//	auto b = std::chrono::high_resolution_clock::now();
	//	std::sort(a.begin(), a.end(), 오름차순);
	//	auto e = std::chrono::high_resolution_clock::now();
	//	// 스톱워치 끝

	//	std::cout << "걸린 시간 - " << e - b << std::endl;
	//}

	//{
	//	for (int& num : a)
	//		num = uid(dre);

	//	// 스톱워치 시작
	//	auto b = std::chrono::high_resolution_clock::now();
	//	std::sort(a.begin(), a.end(), [](int a, int b) {
	//		return a < b;
	//		});
	//	auto e = std::chrono::high_resolution_clock::now();
	//	// 스톱워치 끝

	//	std::cout << "걸린 시간 - " << e - b << std::endl;
	//}

	save("0327.cpp");
}

// std::views::takes : 거르는 기능
// int a[100]; -> std::array<int, 100> a;
// int(*메인)() = main; -> 
// sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-04-01 오후 3:33:50 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	auto 람다 = []() {
		std::cout << "람다" << std::endl;
		};

	std::cout << "람다의 정체" << std::endl;
	std::cout << "람다의 크기 - " << sizeof(람다) << std::endl;
	std::cout << "람다의 위치 - " << std::addressof(람다) << std::endl;
	std::cout << "람다의 타입 - " << typeid(람다).name() << std::endl;

	std::cout << std::endl;


	std::cout << "main의 위치 - " << std::addressof(main) << std::endl;
	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), 오름차순);
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
	}

	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), [](int a, int b) {
			return a < b;
			});
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
	}

	save("0327.cpp");
}

 //std::views::takes : 거르는 기능
 //int a[100]; -> std::array<int, 100> a;
 //int(*메인)() = main; -> 
 //sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-04-01 오후 3:34:39 화요일
================================

//------------------------------------------------------------------------
// 2025.03.25 STL 화78											 (4주 1일)
//------------------------------------------------------------------------
// callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include <print>
#include <ranges>
#include <chrono>
#include "save.h"

// [문제] 랜덤 int 1000만개를 메모리에 저장하라.
// STL의 sort를 사용하여 정렬하라.
// 정렬결과를 앞에서부터 1000개를 화면 출력하라

std::default_random_engine dre;
std::uniform_int_distribution uid{0, 999'9999};


const int NUM{ 1000'0000 };
std::array<int, NUM> a;

bool 오름차순(int a, int b)
{
	return a < b;
}
bool 내림차순(int a, int b)
{
	return a > b;
}

//--------
int main()
//--------
{
	auto 람다 = []() {
		std::cout << "람다" << std::endl;
		};

	std::cout << "람다의 정체" << std::endl;
	std::cout << "람다의 크기 - " << sizeof(람다) << std::endl;
	std::cout << "람다의 위치 - " << std::addressof(람다) << std::endl;
	std::cout << "람다의 타입 - " << typeid(람다).name() << std::endl;

	std::cout << std::endl;


	std::cout << "main의 위치 - " << std::addressof(main) << std::endl;
	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), 오름차순);
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
	}

	{
		for (int& num : a)
			num = uid(dre);

		// 스톱워치 시작
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(a.begin(), a.end(), [](int a, int b) {
			return a < b;
			});
		auto e = std::chrono::high_resolution_clock::now();
		// 스톱워치 끝

		std::cout << "걸린 시간 - " << e - b << std::endl;
	}

	save("0327.cpp");
}

 //std::views::takes : 거르는 기능
 //int a[100]; -> std::array<int, 100> a;
 //int(*메인)() = main; -> 
 //sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-04-01 오후 3:37:48 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	auto 람다 = []() {
		std::cout << "람다" << std::endl;
		};

	std::cout << "람다의 정체" << std::endl;
	std::cout << "람다의 크기 - " << sizeof(람다) << std::endl;
	std::cout << "람다의 위치 - " << std::addressof(람다) << std::endl;
	std::cout << "람다의 타입 - " << typeid(람다).name() << std::endl;

	std::cout << std::endl;

	save("0401.cpp");
}

//std::views::takes : 거르는 기능
//int a[100]; -> std::array<int, 100> a;
//int(*메인)() = main; -> 
//sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-04-01 오후 3:38:33 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	auto 람다 = []() {
		std::cout << "람다" << std::endl;
		};

	람다();

	std::cout << "람다의 정체" << std::endl;
	std::cout << "람다의 크기 - " << sizeof(람다) << std::endl;
	std::cout << "람다의 위치 - " << std::addressof(람다) << std::endl;
	std::cout << "람다의 타입 - " << typeid(람다).name() << std::endl;

	std::cout << std::endl;

	save("0401.cpp");
}

//std::views::takes : 거르는 기능
//int a[100]; -> std::array<int, 100> a;
//int(*메인)() = main; -> 
//sort 함수는 default로 오름차순으로 되어있다.

================================
저장한 시간 : 2025-04-01 오후 3:43:23 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	auto 람다 = []() {
		std::cout << "람다" << std::endl;
		};

	람다();

	std::cout << "람다의 정체" << std::endl;
	std::cout << "람다의 크기 - " << sizeof(람다) << std::endl;
	std::cout << "람다의 위치 - " << std::addressof(람다) << std::endl;
	std::cout << "람다의 타입 - " << typeid(람다).name() << std::endl;

	std::cout << std::endl;

	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 3:52:10 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	auto p = []() {};
	std::cout << std::addressof(p) << std::endl;


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 3:52:38 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	auto p = []() {};
	std::cout << std::addressof(p) << std::endl;

	int num;
	std::cout << std::addressof(num) << std::endl;

	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:03:20 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	class 람다 {
	public:
		void operator( )() {
			std::cout << "안녕, 난 람다야." << std::endl;
		};
	};

	람다 a{};
	a();

	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:04:21 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	class 람다 {
	public:
		void operator( )() {
			std::cout << "안녕, 난 람다야." << std::endl;
		};
	};

	람다 a{};
	a();

	std::cout << "a의 타입 - " << typeid(a).name() << std::endl;

	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:05:38 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"

class 람다 {
public:
	void operator( )() {
		std::cout << "안녕, 난 람다야." << std::endl;
	};
};

//--------
int main()
//--------
{
	

	람다 a{};
	a();

	std::cout << "a의 타입 - " << typeid(a).name() << std::endl;

	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:07:59 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"


//--------
int main()
//--------
{
	class Dog {
	public:
		void operator()() {
			std::cout << "멍" << std::endl;
		}
	};

	Dog dog;

	dog();
	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:11:23 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"

void f() {
	class Dog {
	public:
		void operator()() {
			std::cout << "멍" << std::endl;
		}
	};

	Dog dog;

	dog();
}


//--------
int main()
//--------
{
	f();

	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:11:49 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "save.h"

void f() {
	class Dog {
	public:
		void operator()() {
			std::cout << "멍" << std::endl;
		}
	};

	Dog dog;

	dog();

	std::cout << typeid(dog).name() << std::endl;
}


//--------
int main()
//--------
{
	f();

	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:40:55 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <functional>
#include <algorithm>
#include "save.h"

bool Dog(int a, int b) {
	return a < b;
}

//--------
int main()
//--------
{
	std::array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	std::sort(a.begin(), a.end(), Dog);

	for (int num : a) {
		std::cout << num << " ";
	}
	std::cout << std::endl;


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:41:04 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <functional>
#include <algorithm>
#include "save.h"

bool Dog(int a, int b) {
	return a > b;
}

//--------
int main()
//--------
{
	std::array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	std::sort(a.begin(), a.end(), Dog);

	for (int num : a) {
		std::cout << num << " ";
	}
	std::cout << std::endl;


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:42:46 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <functional>
#include <algorithm>
#include "save.h"



//--------
int main()
//--------
{
	std::array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	class Dog {
	public:
		bool operator()(int a, int b) {
			return a > b;
		}
	};

	Dog dog;

	std::sort(a.begin(), a.end(), dog);

	for (int num : a) {
		std::cout << num << " ";
	}
	std::cout << std::endl;


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:43:44 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <functional>
#include <algorithm>
#include "save.h"

//bool Dog(int a, int b) {
//	return a > b;
//}

//--------
int main()
//--------
{
	std::array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	class Dog {
	public:
		bool operator()(int a, int b) {
			return a > b;
		}
	};

	std::sort(a.begin(), a.end(), Dog());

	for (int num : a) {
		std::cout << num << " ";
	}
	std::cout << std::endl;


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:47:46 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <functional>
#include <algorithm>
#include "save.h"

using namespace std;

//bool Dog(int a, int b) {
//	return a > b;
//}

//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	class X {
	public:
		bool operator()(int a, int b) {
			return a > b;
		}
	};

	function<bool(int, int)> Dog = X();

	sort(a.begin(), a.end(), Dog);

	for (int num : a) {
		cout << num << " ";
	}
	cout << endl;


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:48:41 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <functional>
#include <algorithm>
#include "save.h"

using namespace std;

//bool Dog(int a, int b) {
//	return a > b;
//}

//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	class X {
	public:
		bool operator()(int a, int b) {
			return a > b;
		}
	};

	//function<bool(int, int)> Dog = X::operator;

	X Dog;

	sort(a.begin(), a.end(), Dog);

	for (int num : a) {
		cout << num << " ";
	}
	cout << endl;


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 4:50:24 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <functional>
#include <algorithm>
#include "save.h"

using namespace std;

//bool Dog(int a, int b) {
//	return a > b;
//}

//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	auto Dog = [](int a, int b) {
		return a > b;
		};

	//function<bool(int, int)> Dog = X::operator();


	sort(a.begin(), a.end(), Dog);

	for (int num : a) {
		cout << num << " ";
	}
	cout << endl;


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 5:02:16 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <functional>
#include <algorithm>
#include <random>
#include <print>
#include "save.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution uid;
uniform_int_distribution uidLen{ 3, 50 };
uniform_int_distribution<int> uidName{ 'a', 'z' };

class Dog {
public:
	Dog() {
		num = uid(dre);

		int len = uidLen(dre);

		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}
	
	void show() const {
		println("{:10} - {}", num, name);
	}

private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.

//bool Dog(int a, int b) 
//{
//	return a > b;
//}

//--------
int main()
//--------
{
	//array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	/*auto Dog = [](int a, int b) {
		return a > b;
		};*/

	//function<bool(int, int)> Dog = X::operator();


	//sort(a.begin(), a.end(), Dog);

	/*for (int num : a) {
		cout << num << " ";
	}
	cout << endl;*/

	for (int i = 0; i < 10; ++i) {
		Dog dog;
		dog.show();
	}


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 5:05:00 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <functional>
#include <algorithm>
#include <random>
#include <print>
#include "save.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution uid;
uniform_int_distribution uidLen{ 3, 50 };
uniform_int_distribution<int> uidName{ 'a', 'z' };

class Dog {
public:
	Dog() {
		num = uid(dre);

		int len = uidLen(dre);

		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}
	
	void show() const {
		println("{:10} - {}", num, name);
	}

private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.

//bool Dog(int a, int b) 
//{
//	return a > b;
//}

//--------
int main()
//--------
{
	//array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	/*auto Dog = [](int a, int b) {
		return a > b;
		};*/

	//function<bool(int, int)> Dog = X::operator();


	//sort(a.begin(), a.end(), Dog);

	/*for (int num : a) {
		cout << num << " ";
	}
	cout << endl;*/

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		dog.show();
	}


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-01 오후 5:06:56 화요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <functional>
#include <algorithm>
#include <random>
#include <print>
#include <fstream>
#include "save.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution uid;
uniform_int_distribution uidLen{ 3, 50 };
uniform_int_distribution<int> uidName{ 'a', 'z' };

class Dog {
public:
	Dog() {
		num = uid(dre);

		int len = uidLen(dre);

		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}
	
	void show() const {
		println("{:10} - {}", num, name);
	}

private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성

	friend ostream& operator <<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.

//bool Dog(int a, int b) 
//{
//	return a > b;
//}

//--------
int main()
//--------
{

	ofstream out{ "Dog 십만마리" };
	//array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	/*auto Dog = [](int a, int b) {
		return a > b;
		};*/

	//function<bool(int, int)> Dog = X::operator();


	//sort(a.begin(), a.end(), Dog);

	/*for (int num : a) {
		cout << num << " ";
	}
	cout << endl;*/

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-03 오전 10:41:15 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include "save.h"

using namespace std;

class Dog {
public:
	
private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성

	friend ostream& operator <<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
	/*friend istream& operator >> (istream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}*/
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.
// [문제] 틀림없이 Dog 10만마리 객체가 기록되었다.
// 파일 "Dog 십만마리"를 열어 모든 Dog 객체를 메모리에 저장하라
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력결과를 적어라.
// 메모리에 저장한 Dog 객체를 name 길이기준 오름차순으로 정렬하라
// 앞에서부터 5000개의 정보를 화면에 출력하라.

//bool Dog(int a, int b) 
//{
//	return a > b;
//}

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	array<Dog, 10'0000> dog;

	in.read((char*)dog.data(), dog.size() * sizeof(Dog));

	for (Dog d : dog) {
		cout << d << endl;
	}

	//array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	/*auto Dog = [](int a, int b) {
		return a > b;
		};*/

	//function<bool(int, int)> Dog = X::operator();


	//sort(a.begin(), a.end(), Dog);

	/*for (int num : a) {
		cout << num << " ";
	}
	cout << endl;*/

	/*for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}*/


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-03 오전 10:41:24 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include "save.h"

using namespace std;

class Dog {
public:
	
private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성

	friend ostream& operator <<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
	/*friend istream& operator >> (istream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}*/
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.
// [문제] 틀림없이 Dog 10만마리 객체가 기록되었다.
// 파일 "Dog 십만마리"를 열어 모든 Dog 객체를 메모리에 저장하라
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력결과를 적어라.
// 메모리에 저장한 Dog 객체를 name 길이기준 오름차순으로 정렬하라
// 앞에서부터 5000개의 정보를 화면에 출력하라.

//bool Dog(int a, int b) 
//{
//	return a > b;
//}

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	array<Dog, 10'0000> dog;

	in.read((char*)dog.data(), dog.size() * sizeof(Dog));

	for (Dog d : dog) {
		cout << d << endl;
	}

	//array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	/*auto Dog = [](int a, int b) {
		return a > b;
		};*/

	//function<bool(int, int)> Dog = X::operator();


	//sort(a.begin(), a.end(), Dog);

	/*for (int num : a) {
		cout << num << " ";
	}
	cout << endl;*/

	/*for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}*/


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-03 오전 10:47:29 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include "save.h"

using namespace std;

class Dog {
public:
	
private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성

	friend ostream& operator <<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
	/*friend istream& operator >> (istream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}*/
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.
// [문제] 틀림없이 Dog 10만마리 객체가 기록되었다.
// 파일 "Dog 십만마리"를 열어 모든 Dog 객체를 메모리에 저장하라
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력결과를 적어라.
// 메모리에 저장한 Dog 객체를 name 길이기준 오름차순으로 정렬하라
// 앞에서부터 5000개의 정보를 화면에 출력하라.

//bool Dog(int a, int b) 
//{
//	return a > b;
//}

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	array<Dog, 10'0000> dog;

	in.read((char*)dog.data(), dog.size() * sizeof(Dog));

	for (Dog d : dog) {
		cout << d << endl;
	}

	//array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	/*auto Dog = [](int a, int b) {
		return a > b;
		};*/

	//function<bool(int, int)> Dog = X::operator();


	//sort(a.begin(), a.end(), Dog);

	/*for (int num : a) {
		cout << num << " ";
	}
	cout << endl;*/

	/*for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}*/


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-03 오전 10:52:06 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include "save.h"

using namespace std;

class Dog {
public:
	
private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성

	friend ostream& operator <<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
	/*friend istream& operator >> (istream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}*/
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.
// [문제] 틀림없이 Dog 10만마리 객체가 기록되었다.
// 파일 "Dog 십만마리"를 열어 모든 Dog 객체를 메모리에 저장하라
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력결과를 적어라.
// 메모리에 저장한 Dog 객체를 name 길이기준 오름차순으로 정렬하라
// 앞에서부터 5000개의 정보를 화면에 출력하라.

//bool Dog(int a, int b) 
//{
//	return a > b;
//}

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	array<Dog, 10'0000> dog;

	in.read((char*)dog.data(), dog.size() * sizeof(Dog));

	for (Dog d : dog) {
		cout << d << endl;
	}

	//array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	/*auto Dog = [](int a, int b) {
		return a > b;
		};*/

	//function<bool(int, int)> Dog = X::operator();


	//sort(a.begin(), a.end(), Dog);

	/*for (int num : a) {
		cout << num << " ";
	}
	cout << endl;*/

	/*for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}*/


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-03 오전 10:52:52 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include "save.h"

using namespace std;

class Dog {
public:
	
private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성

	friend ostream& operator <<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
	/*friend istream& operator >> (istream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}*/
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.
// [문제] 틀림없이 Dog 10만마리 객체가 기록되었다.
// 파일 "Dog 십만마리"를 열어 모든 Dog 객체를 메모리에 저장하라
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력결과를 적어라.
// 메모리에 저장한 Dog 객체를 name 길이기준 오름차순으로 정렬하라
// 앞에서부터 5000개의 정보를 화면에 출력하라.

//bool Dog(int a, int b) 
//{
//	return a > b;
//}

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	array<Dog, 10'0000> dog;

	in.read((char*)dog.data(), dog.size() * sizeof(Dog));

	for (Dog d : dog) {
		cout << d << endl;
	}

	//array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	/*auto Dog = [](int a, int b) {
		return a > b;
		};*/

	//function<bool(int, int)> Dog = X::operator();


	//sort(a.begin(), a.end(), Dog);

	/*for (int num : a) {
		cout << num << " ";
	}
	cout << endl;*/

	/*for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}*/


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-03 오전 10:56:51 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include "save.h"

using namespace std;

class Dog {
public:
	
private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성

	friend ostream& operator <<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
	/*friend istream& operator >> (istream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}*/
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.
// [문제] 틀림없이 Dog 10만마리 객체가 기록되었다.
// 파일 "Dog 십만마리"를 열어 모든 Dog 객체를 메모리에 저장하라
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력결과를 적어라.
// 메모리에 저장한 Dog 객체를 name 길이기준 오름차순으로 정렬하라
// 앞에서부터 5000개의 정보를 화면에 출력하라.

//bool Dog(int a, int b) 
//{
//	return a > b;
//}

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	array<Dog, 10'0000> dog;

	in.read((char*)dog.data(), dog.size() * sizeof(Dog));

	for (Dog d : dog) {
		cout << d << endl;
	}

	//array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	/*auto Dog = [](int a, int b) {
		return a > b;
		};*/

	//function<bool(int, int)> Dog = X::operator();


	//sort(a.begin(), a.end(), Dog);

	/*for (int num : a) {
		cout << num << " ";
	}
	cout << endl;*/

	/*for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}*/


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-03 오전 10:57:10 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include "save.h"

using namespace std;

class Dog {
public:
	
private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성

	friend ostream& operator <<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
	/*friend istream& operator >> (istream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}*/
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.
// [문제] 틀림없이 Dog 10만마리 객체가 기록되었다.
// 파일 "Dog 십만마리"를 열어 모든 Dog 객체를 메모리에 저장하라
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력결과를 적어라.
// 메모리에 저장한 Dog 객체를 name 길이기준 오름차순으로 정렬하라
// 앞에서부터 5000개의 정보를 화면에 출력하라.

//bool Dog(int a, int b) 
//{
//	return a > b;
//}

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	array<Dog, 10'0000> dog;

	in.read((char*)dog.data(), dog.size() * sizeof(Dog));

	for (Dog d : dog) {
		cout << d << endl;
	}

	//array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	/*auto Dog = [](int a, int b) {
		return a > b;
		};*/

	//function<bool(int, int)> Dog = X::operator();


	//sort(a.begin(), a.end(), Dog);

	/*for (int num : a) {
		cout << num << " ";
	}
	cout << endl;*/

	/*for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}*/


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-03 오전 10:58:05 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include "save.h"

using namespace std;

class Dog {
public:
	
private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성

	friend ostream& operator <<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
	/*friend istream& operator >> (istream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}*/
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.
// [문제] 틀림없이 Dog 10만마리 객체가 기록되었다.
// 파일 "Dog 십만마리"를 열어 모든 Dog 객체를 메모리에 저장하라
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력결과를 적어라.
// 메모리에 저장한 Dog 객체를 name 길이기준 오름차순으로 정렬하라
// 앞에서부터 5000개의 정보를 화면에 출력하라.

//bool Dog(int a, int b) 
//{
//	return a > b;
//}

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	array<Dog, 10'0000> dog;

	in.read((char*)dog.data(), dog.size() * sizeof(Dog));

	for (Dog d : dog) {
		cout << d << endl;
	}

	//array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
	// [문제] 내림차순 정렬할 수 있게 하라

	/*auto Dog = [](int a, int b) {
		return a > b;
		};*/

	//function<bool(int, int)> Dog = X::operator();


	//sort(a.begin(), a.end(), Dog);

	/*for (int num : a) {
		cout << num << " ";
	}
	cout << endl;*/

	/*for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}*/


	save("0401.cpp");
}

================================
저장한 시간 : 2025-04-03 오전 11:00:40 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// callable types - 호출가능한 타입 -> 모든 호출 가능 타입을 나타낼 수 있는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수
// 4. 함수객체 - 함수 호출 연산자를 오버로딩한 클래스로 만든 객체 (function object)
// 5. 멤버함수 
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include <ranges>
#include "save.h"

using namespace std;

class Dog {
public:
	bool operator<( const Dog& other ) const {
		return name.size() < other.name.size();
	}

	void show() const {
		println("{:15} - {}", num, name);
	}

private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성

	friend ostream& operator <<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
	friend istream& operator >>(istream& is, Dog& dog) {
		return is >> dog.num >> dog.name;
	}
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.
// [문제] 틀림없이 Dog 10만마리 객체가 기록되었다.
// 파일 "Dog 십만마리"를 열어 모든 Dog 객체를 메모리에 저장하라
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력결과를 적어라.
// 메모리에 저장한 Dog 객체를 name 길이기준 오름차순으로 정렬하라
// 앞에서부터 5000개의 정보를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보입니다." << endl;
	dogs.back().show();

	cout << "이름 길이기준 오름차순으로 정렬합니다" << endl;
	sort(dogs.begin(), dogs.end());

	cout << "정렬 결과 중 앞에서 부터 5000개를 출력합니다" << endl;

	for (const Dog& dog : dogs)
		dog.show();

	save("0403.cpp");
}

================================
저장한 시간 : 2025-04-03 오전 11:05:19 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include <ranges>
#include "save.h"

using namespace std;

class Dog {
public:
	bool operator>( const Dog& other ) const {
		return name.size() > other.name.size();
	}

	void show() const {
		println("{:15} - {}", num, name);
	}

private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성

	friend ostream& operator <<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
	friend istream& operator >>(istream& is, Dog& dog) {
		return is >> dog.num >> dog.name;
	}
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.
// [문제] 틀림없이 Dog 10만마리 객체가 기록되었다.
// 파일 "Dog 십만마리"를 열어 모든 Dog 객체를 메모리에 저장하라
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력결과를 적어라.
// 메모리에 저장한 Dog 객체를 name 길이기준 오름차순으로 정렬하라
// 앞에서부터 5000개의 정보를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보입니다." << endl;
	dogs.back().show();

	cout << "이름 길이기준 오름차순으로 정렬합니다" << endl;
	sort(dogs.begin(), dogs.end(), greater<>());

	cout << "정렬 결과 중 앞에서 부터 5000개를 출력합니다" << endl;

	for (const Dog& dog : dogs)
		dog.show();

	save("0403.cpp");
}

================================
저장한 시간 : 2025-04-03 오전 11:07:16 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include <ranges>
#include "save.h"

using namespace std;

class Dog {
public:
	bool operator<( const Dog& other ) const {
		return name.size() < other.name.size();
	}

	void show() const {
		println("{:15} - {}", num, name);
	}

private:
	string name; // [3, 50] 사이의 랜덤 소문자로만 구성
	int num; // 랜덤 int 값으로 구성

	friend ostream& operator <<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
	friend istream& operator >>(istream& is, Dog& dog) {
		return is >> dog.num >> dog.name;
	}
};

// [상황] Dog 객체 10만개를 파일 "Dog 십만마리" 에 기록하였다.
// 파일은 다음과 같이 열었다.
//		ofstream out("Dog 십만마리");
// 각 Dog 객체는 
//		out << dog; 와 같이 기록하였다.
// [문제] 틀림없이 Dog 10만마리 객체가 기록되었다.
// 파일 "Dog 십만마리"를 열어 모든 Dog 객체를 메모리에 저장하라
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력결과를 적어라.
// 메모리에 저장한 Dog 객체를 name 길이기준 오름차순으로 정렬하라
// 앞에서부터 5000개의 정보를 화면에 출력하라.

array<Dog, 10'0000> dogs;

//--------
int main()
//--------
{
	ifstream in{ "Dog 십만마리" };
	if (not in)
		return 20250401;

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보입니다." << endl;
	dogs.back().show();

	cout << "이름 길이기준 오름차순으로 정렬합니다" << endl;
	sort(dogs.begin(), dogs.end());

	cout << "정렬 결과 중 앞에서 부터 5000개를 출력합니다" << endl;

	for (const Dog& dog : dogs)
		dog.show();

	save("0403.cpp");
}

// 내림차순 : sort(dogs.begin(), dogs.end(), greater<>());
// bool operator<( const Dog& other ) const {
// return name.size() < other.name.size();
//		}

// 오름차순 : sort(dogs.begin(), dogs.end());
// bool operator>( const Dog& other ) const {
// return name.size() > other.name.size();
//		}

================================
저장한 시간 : 2025-04-03 오전 11:56:10 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include <ranges>
#include <memory>
#include "save.h"

using namespace std;

// 표준 std::string과 유사한 동작을 하는 클래스
class STRING {
public:
	STRING(const char* s) : len { strlen(s) } {
		p.reset(new char[len]);// = make_unique<char[]>(len);
		memcpy(p.get(), s, len);
	}

	size_t size() const {
		return len;
	}

private:
	size_t len;
	unique_ptr<char[]> p;


	friend ostream& operator << (ostream & os, const STRING& str) {
		for (int i = 0; i < str.len; ++i)
			os << str.p[i];
		return os;
	}
};

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };


	cout << "s가 관리하는 자원의 바이트 수 - " << s.size() << endl;
	cout << s << endl;


	save("0403.cpp");
}




//==============================================================
// 내림차순 : sort(dogs.begin(), dogs.end(), greater<>());
// bool operator<( const Dog& other ) const {
// return name.size() < other.name.size();
//		}

// 오름차순 : sort(dogs.begin(), dogs.end());
// bool operator>( const Dog& other ) const {
// return name.size() > other.name.size();
//		}

// && : r-value 레퍼런스

// oop -> 특정 type을 위한 coding star
// generic -> 타입과 무관한

================================
저장한 시간 : 2025-04-03 오전 11:59:24 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include <ranges>
#include <memory>
#include "save.h"

using namespace std;

// 표준 std::string과 유사한 동작을 하는 클래스
class STRING {
public:
	STRING(const char* s) : len { strlen(s) } {
		p.reset();
		p = make_unique<char[]>(len); // p가 자원을 확보하게 한다.
		memcpy(p.get(), s, len);
	}

	size_t size() const {
		return len;
	}

private:
	size_t len;
	unique_ptr<char[]> p;


	friend ostream& operator << (ostream & os, const STRING& str) {
		for (int i = 0; i < str.len; ++i)
			os << str.p[i];
		return os;
	}
};

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };


	cout << "s가 관리하는 자원의 바이트 수 - " << s.size() << endl;
	cout << s << endl;


	save("0403.cpp");
}




//==============================================================
// 내림차순 : sort(dogs.begin(), dogs.end(), greater<>());
// bool operator<( const Dog& other ) const {
// return name.size() < other.name.size();
//		}

// 오름차순 : sort(dogs.begin(), dogs.end());
// bool operator>( const Dog& other ) const {
// return name.size() > other.name.size();
//		}

// && : r-value 레퍼런스

// oop -> 특정 type을 위한 coding star
// generic -> 타입과 무관한

// lvalue : location value

================================
저장한 시간 : 2025-04-03 오후 12:07:13 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include <ranges>
#include <memory>
#include "save.h"

using namespace std;

// 표준 std::string과 유사한 동작을 하는 클래스
class STRING {
public:
	STRING(const char* s) : len { strlen(s) } {
		p.reset();
		p = make_unique<char[]>(len); // p가 자원을 확보하게 한다.
		memcpy(p.get(), s, len);
	}

	size_t size() const {
		return len;
	}

	STRING(const STRING& other) : len(other.len), p(make_unique<char[]>(other.len)) {
		memcpy(p.get(), other.p.get(), len);
	}

private:
	size_t len;
	unique_ptr<char[]> p;


	friend ostream& operator << (ostream & os, const STRING& str) {
		for (int i = 0; i < str.len; ++i)
			os << str.p[i];
		return os;
	}
};

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	STRING t = s;

	cout << s << endl;
	cout << t << endl;


	save("0403.cpp");
}




//==============================================================
// 내림차순 : sort(dogs.begin(), dogs.end(), greater<>());
// bool operator<( const Dog& other ) const {
// return name.size() < other.name.size();
//		}

// 오름차순 : sort(dogs.begin(), dogs.end());
// bool operator>( const Dog& other ) const {
// return name.size() > other.name.size();
//		}

// && : r-value 레퍼런스

// oop -> 특정 type을 위한 coding star
// generic -> 타입과 무관한

// lvalue : location value

================================
저장한 시간 : 2025-04-03 오후 12:08:24 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include <ranges>
#include <memory>
#include "save.h"

using namespace std;

// 표준 std::string과 유사한 동작을 하는 클래스
class STRING {
public:
	STRING(const char* s) : len { strlen(s) } {
		p.reset();
		p = make_unique<char[]>(len); // p가 자원을 확보하게 한다.
		memcpy(p.get(), s, len);
	}

	size_t size() const {
		return len;
	}

	STRING(const STRING& other) : len(other.len), p(make_unique<char[]>(other.len)) {
		memcpy(p.get(), other.p.get(), len);
	}

private:
	size_t len;
	unique_ptr<char[]> p;


	friend ostream& operator << (ostream & os, const STRING& str) {
		for (int i = 0; i < str.len; ++i)
			os << str.p[i];
		return os;
	}
};

//--------
int main()
//--------
{
	STRING s{ "?" };

	STRING t = s;

	cout << s << endl;
	cout << t << endl;


	save("0403.cpp");
}




//==============================================================
// 내림차순 : sort(dogs.begin(), dogs.end(), greater<>());
// bool operator<( const Dog& other ) const {
// return name.size() < other.name.size();
//		}

// 오름차순 : sort(dogs.begin(), dogs.end());
// bool operator>( const Dog& other ) const {
// return name.size() > other.name.size();
//		}

// && : r-value 레퍼런스

// oop -> 특정 type을 위한 coding star
// generic -> 타입과 무관한

// lvalue : location value

================================
저장한 시간 : 2025-04-03 오후 12:12:43 목요일
================================

//------------------------------------------------------------------------
// 2025.04.01 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include <ranges>
#include <memory>
#include "save.h"

using namespace std;

// 표준 std::string과 유사한 동작을 하는 클래스
class STRING {
public:
	STRING(const char* s) : len{ strlen(s) } {
		p.reset();
		p = make_unique<char[]>(len); // p가 자원을 확보하게 한다.
		memcpy(p.get(), s, len);
	}

	STRING(const STRING& other) : len{ other.len } {
		p.reset();
		p = make_unique<char[]>(len);
		memcpy(p.get(), other.p.get(), len);
	}

	size_t size() const {
		return len;
	}

	STRING& operator=(const STRING& other) {
		len = other.len;
		memcpy(p.get(), other.p.get(), len);
	}

private:
	size_t len;
	unique_ptr<char[]> p;


	friend ostream& operator << (ostream & os, const STRING& str) {
		for (int i = 0; i < str.len; ++i)
			os << str.p[i];
		return os;
	}
};

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	STRING t = s;

	cout << s << endl;
	cout << t << endl;


	save("0403.cpp");
}




//==============================================================
// 내림차순 : sort(dogs.begin(), dogs.end(), greater<>());
// bool operator<( const Dog& other ) const {
// return name.size() < other.name.size();
//		}

// 오름차순 : sort(dogs.begin(), dogs.end());
// bool operator>( const Dog& other ) const {
// return name.size() > other.name.size();
//		}

// && : r-value 레퍼런스

// oop -> 특정 type을 위한 coding star
// generic -> 타입과 무관한

// lvalue : location value

================================
저장한 시간 : 2025-04-08 오후 3:32:24 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <print>
#include <algorithm>
#include <ranges>
#include <memory>
#include "save.h"

using namespace std;

// 표준 std::string과 유사한 동작을 하는 클래스
class STRING {
public:

	// 디폴트를 반드시 코딩

	STRING(const char* s) : len{ strlen(s) } {
		p.reset();
		p = make_unique<char[]>(len); // p가 자원을 확보하게 한다.
		memcpy(p.get(), s, len);
	}

	STRING(const STRING& other) : len{ other.len } {
		p.reset();
		p = make_unique<char[]>(len);
		memcpy(p.get(), other.p.get(), len);
	}

	// copy assignment operator 를 반드시 코딩해야 한다.

	size_t size() const {
		return len;
	}

private:
	size_t len;
	unique_ptr<char[]> p;


	friend ostream& operator << (ostream& os, const STRING& str) {
		for (int i = 0; i < str.len; ++i)
			os << str.p[i];
		return os;
	}
};

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	STRING t = s;

	cout << s << endl;
	cout << t << endl;


	save("0408.cpp");
}

================================
저장한 시간 : 2025-04-08 오후 3:47:52 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"
#include "save.h"

using namespace std;



//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	STRING t = s;

	cout << s << endl;
	cout << t << endl;


	save("0408.cpp");
}

================================
저장한 시간 : 2025-04-08 오후 3:57:13 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"
#include "save.h"

using namespace std;



//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	STRING t;

	t = s;

	save("0408.cpp");
}

================================
저장한 시간 : 2025-04-08 오후 4:11:18 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"
#include "save.h"

using namespace std;

extern bool 관찰;								// 관찰하고 싶으면 true로 설정하자

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	save("0408.cpp");
}

================================
저장한 시간 : 2025-04-08 오후 4:12:36 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"
#include "save.h"

using namespace std;

extern bool 관찰;								// 관찰하고 싶으면 true로 설정하자

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	save("0408.cpp");
}

================================
저장한 시간 : 2025-04-08 오후 4:13:40 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"
#include "save.h"

using namespace std;

extern bool 관찰;								// 관찰하고 싶으면 true로 설정하자

//--------
int main()
//--------
{
	STRING s{ "std::string과 유사한 클래스" };

	save("0408.cpp");
}

================================
저장한 시간 : 2025-04-08 오후 4:20:47 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"
#include "save.h"

using namespace std;

extern bool 관찰;								// 관찰하고 싶으면 true로 설정하자


//--------
int main()
//--------
{
	관찰 = true;
	STRING s{ "std::string과 유사한 클래스" };

	save("0408.cpp");
}

================================
저장한 시간 : 2025-04-08 오후 4:22:40 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"
#include "save.h"

using namespace std;

extern bool 관찰;								// 관찰하고 싶으면 true로 설정하자

STRING s{ "이제 준비가 되었다." };

//--------
int main()
//--------
{
	관찰 = true;

	cout << "메인 시작" << endl;

	STRING t;
	t = s;


	save("0408.cpp");
	cout << "메인 끝" << endl;
}

================================
저장한 시간 : 2025-04-08 오후 4:23:16 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"
#include "save.h"

using namespace std;

extern bool 관찰;								// 관찰하고 싶으면 true로 설정하자

STRING s{ "이제 준비가 되었다." };

//--------
int main()
//--------
{
	관찰 = true;

	cout << "메인 시작" << endl;

	STRING t;
	t = s;


	save("0408.cpp");
	cout << "메인 끝" << endl;
}

================================
저장한 시간 : 2025-04-08 오후 4:26:04 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"
#include "save.h"

using namespace std;

extern bool 관찰;								// 관찰하고 싶으면 true로 설정하자

STRING s{ "이제 준비가 되었다." };

//--------
int main()
//--------
{
	관찰 = true;

	cout << "메인 시작" << endl;

	STRING t;
	t = s;


	save("0408.cpp");
	cout << "메인 끝" << endl;
}

================================
저장한 시간 : 2025-04-08 오후 4:28:18 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"
#include "save.h"

using namespace std;

extern bool 관찰;								// 관찰하고 싶으면 true로 설정하자

STRING s{ "이제 준비가 되었다." };

//--------
int main()
//--------
{
	관찰 = true;

	cout << "메인 시작" << endl;

	new STRING{"1234567"};

	STRING t;
	t = s;

	save("0408.cpp");
	cout << "메인 끝" << endl;
}

================================
저장한 시간 : 2025-04-08 오후 4:31:16 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include "STRING.h"
#include "save.h"

using namespace std;

extern bool 관찰;								// 관찰하고 싶으면 true로 설정하자

STRING s{ "이제 준비가 되었다." };

//--------
int main()
//--------
{
	관찰 = true;

	cout << "메인 시작" << endl;

	new STRING{"1234567"};

	STRING t;
	t = s;

	save("0408.cpp");
	cout << "메인 끝" << endl;
}

================================
저장한 시간 : 2025-04-08 오후 4:34:44 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	array<STRING, 5> a{"1", "333", "55555", "22", "4444"};

	for (auto s : a)
		cout << s << endl;

	save("0408.cpp");
}

================================
저장한 시간 : 2025-04-08 오후 4:35:17 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	array<STRING, 5> a{"1", "333", "55555", "22", "4444"};

	관찰 = true;
	for (auto s : a)
		cout << s << endl;
	관찰 = false;

	save("0408.cpp");
}

================================
저장한 시간 : 2025-04-08 오후 4:36:00 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	array<STRING, 5> a{"1", "333", "55555", "22", "4444"};

	관찰 = true;
	for (const auto& s : a)
		cout << s << endl;
	관찰 = false;

	save("0408.cpp");
}

================================
저장한 시간 : 2025-04-08 오후 4:54:13 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	array<STRING, 5> a{"1", "333", "55555", "22", "4444"};

// [문제] a를 글자길이 기준 오름차순으로 정렬하라.
	관찰 = true;
	sort(a.begin(), a.end(), [](STRING a, STRING b) {
		return a.size() > b.size();
		});
	관찰 = false;

	for (const STRING& s : a)
		cout << s << endl;

	save("0408.cpp");
}

// for (auto s : a)
//		cout << s << endl;
// 객체가 복사생성되고 소멸을 반복한다
// ->
// for (const STRING& s : a)
//		cout << s << endl;
// 이래야 객체를 생성하지 않는다

================================
저장한 시간 : 2025-04-08 오후 4:54:40 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	array<STRING, 5> a{"1", "333", "55555", "22", "4444"};

// [문제] a를 글자길이 기준 오름차순으로 정렬하라.

	관찰 = true;
	sort(a.begin(), a.end(), [](STRING a, STRING b) {
		return a.size() < b.size();
		});
	관찰 = false;

	for (const STRING& s : a)
		cout << s << endl;

	save("0408.cpp");
}

// for (auto s : a)
//		cout << s << endl;
// 객체가 복사생성되고 소멸을 반복한다
// ->
// for (const STRING& s : a)
//		cout << s << endl;
// 이래야 객체를 생성하지 않는다

================================
저장한 시간 : 2025-04-08 오후 4:54:59 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	array<STRING, 5> a{"1", "333", "55555", "22", "4444"};

// [문제] a를 글자길이 기준 오름차순으로 정렬하라.

	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		});
	관찰 = false;

	for (const STRING& s : a)
		cout << s << endl;

	save("0408.cpp");
}

// for (auto s : a)
//		cout << s << endl;
// 객체가 복사생성되고 소멸을 반복한다
// ->
// for (const STRING& s : a)
//		cout << s << endl;
// 이래야 객체를 생성하지 않는다

================================
저장한 시간 : 2025-04-08 오후 5:15:45 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	array<STRING, 5> a{"1", "333", "55555", "22", "4444"};

// [문제] a를 글자길이 기준 오름차순으로 정렬하라.

	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		});
	관찰 = false;

	for (const STRING& s : a)
		cout << s << endl;

	save("0408.cpp");
}

// for (auto s : a)
//		cout << s << endl;
// 객체가 복사생성되고 소멸을 반복한다
// ->
// for (const STRING& s : a)
//		cout << s << endl;
// 이래야 객체를 생성하지 않는다

//============================================================================================
// 이동 없이 정렬한 결과
// 
//관찰 = true;
//sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
//	return a.size() < b.size();
//	});
//관찰 = false;
//
//[6] - 복사생성자           자원수 : 3      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc3580
//[2] - 복사 operator=       자원수 : 3      주소 : 0x15efaff8d8, 자원의 주소 : 0x1bdb8bc3590
//[6] - 소멸자               자원수 : 3      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc3580
//[7] - 복사생성자           자원수 : 5      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc35a0
//[3] - 복사 operator=       자원수 : 5      주소 : 0x15efaff8f0, 자원의 주소 : 0x1bdb8bc3550
//[7] - 소멸자               자원수 : 5      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc35a0
//[8] - 복사생성자           자원수 : 2      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc3510
//[4] - 복사 operator=       자원수 : 5      주소 : 0x15efaff908, 자원의 주소 : 0x1bdb8bc3580
//[3] - 복사 operator=       자원수 : 3      주소 : 0x15efaff8f0, 자원의 주소 : 0x1bdb8bc34d0
//[2] - 복사 operator=       자원수 : 2      주소 : 0x15efaff8d8, 자원의 주소 : 0x1bdb8bc3530
//[8] - 소멸자               자원수 : 2      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc3510
//[9] - 복사생성자           자원수 : 4      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc35a0
//[5] - 복사 operator=       자원수 : 5      주소 : 0x15efaff920, 자원의 주소 : 0x1bdb8bc3450
//[4] - 복사 operator=       자원수 : 4      주소 : 0x15efaff908, 자원의 주소 : 0x1bdb8bc34e0
//[9] - 소멸자               자원수 : 4      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc35a0
//============================================================================================

================================
저장한 시간 : 2025-04-08 오후 5:18:29 화요일
================================

//------------------------------------------------------------------------
// 2025.04.08 STL 화78											 (5주 1일)
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	array<STRING, 5> a{"1", "333", "55555", "22", "4444"};

// [문제] a를 글자길이 기준 오름차순으로 정렬하라.

	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		});
	관찰 = false;

	for (const STRING& s : a)
		cout << s << endl;

	save("0408.cpp");
}

// for (auto s : a)
//		cout << s << endl;
// 객체가 복사생성되고 소멸을 반복한다
// ->
// for (const STRING& s : a)
//		cout << s << endl;
// 이래야 객체를 생성하지 않는다

//============================================================================================
// 이동 없이 정렬한 결과
// 
//관찰 = true;
//sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
//	return a.size() < b.size();
//	});
//관찰 = false;
//
//[6] - 복사생성자           자원수 : 3      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc3580
//[2] - 복사 operator=       자원수 : 3      주소 : 0x15efaff8d8, 자원의 주소 : 0x1bdb8bc3590
//[6] - 소멸자               자원수 : 3      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc3580
//[7] - 복사생성자           자원수 : 5      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc35a0
//[3] - 복사 operator=       자원수 : 5      주소 : 0x15efaff8f0, 자원의 주소 : 0x1bdb8bc3550
//[7] - 소멸자               자원수 : 5      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc35a0
//[8] - 복사생성자           자원수 : 2      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc3510
//[4] - 복사 operator=       자원수 : 5      주소 : 0x15efaff908, 자원의 주소 : 0x1bdb8bc3580
//[3] - 복사 operator=       자원수 : 3      주소 : 0x15efaff8f0, 자원의 주소 : 0x1bdb8bc34d0
//[2] - 복사 operator=       자원수 : 2      주소 : 0x15efaff8d8, 자원의 주소 : 0x1bdb8bc3530
//[8] - 소멸자               자원수 : 2      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc3510
//[9] - 복사생성자           자원수 : 4      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc35a0
//[5] - 복사 operator=       자원수 : 5      주소 : 0x15efaff920, 자원의 주소 : 0x1bdb8bc3450
//[4] - 복사 operator=       자원수 : 4      주소 : 0x15efaff908, 자원의 주소 : 0x1bdb8bc34e0
//[9] - 소멸자               자원수 : 4      주소 : 0x15efaff840, 자원의 주소 : 0x1bdb8bc35a0
//============================================================================================
// 이동 있이 정렬한 결과

================================
저장한 시간 : 2025-04-10 오전 11:02:19 목요일
================================

//------------------------------------------------------------------------
// 2025.04.10													
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//--------
int main()
//--------
{
	관찰 = true;

	STRING s{ "이동될 문자열" };
	STRING t = move(s);

	cout << s << endl;
	cout << t << endl;

	save("0410.cpp");
}

================================
저장한 시간 : 2025-04-10 오전 11:30:17 목요일
================================

//------------------------------------------------------------------------
// 2025.04.10													
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

// [문제] "0410.cpp"에 있는 단어(공백으로 분리된 char의 집합)를 모두 읽어라.
// 단어를 우리가 만든 STRING에 저장하라.
// 다음 코드가 문제없이 실행되면 좋겠다.

//--------
int main()
//--------
{
	STRING s;

	ifstream in{ "0410.cpp" };
	if (not in)
		return 20250410;

	while (in >> s) {
		cout << s << endl;
	}

	save("0410.cpp");
}

// cout << s << endl; -> xvalue를 사용하는 코드의 결과는 정의되어 있지 않음

================================
저장한 시간 : 2025-04-10 오전 11:31:52 목요일
================================

//------------------------------------------------------------------------
// 2025.04.10													
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

// [문제] "0410.cpp"에 있는 단어(공백으로 분리된 char의 집합)를 모두 읽어라.
// 단어를 우리가 만든 STRING에 저장하라.
// 다음 코드가 문제없이 실행되면 좋겠다.

//--------
int main()
//--------
{
	STRING s;

	ifstream in{ "0410.cpp" };
	if (not in)
		return 20250410;

	while (in >> s) {
		cout << s << endl;
	}

	save("0410.cpp");
}

// cout << s << endl; -> xvalue를 사용하는 코드의 결과는 정의되어 있지 않음

================================
저장한 시간 : 2025-04-10 오전 11:37:43 목요일
================================

//------------------------------------------------------------------------
// 2025.04.10													
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

// [문제] "0410.cpp"에 있는 단어(공백으로 분리된 char의 집합)를 모두 읽어라.
// 단어를 우리가 만든 STRING에 저장하라.
// 다음 코드가 문제없이 실행되면 좋겠다.

//--------
int main()
//--------
{
	STRING s;

	ifstream in{ "0410.cpp" };
	if (not in)
		return 20250410;

	while (in >> s) {
		cout << s << endl;
	}

	save("0410.cpp");
}

// cout << s << endl; -> xvalue를 사용하는 코드의 결과는 정의되어 있지 않음

================================
저장한 시간 : 2025-04-10 오전 11:38:06 목요일
================================

//------------------------------------------------------------------------
// 2025.04.10													
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

// [문제] "0410.cpp"에 있는 단어(공백으로 분리된 char의 집합)를 모두 읽어라.
// 단어를 우리가 만든 STRING에 저장하라.
// 다음 코드가 문제없이 실행되면 좋겠다.

//--------
int main()
//--------
{
	STRING s;

	ifstream in{ "0410.cpp" };
	if (not in)
		return 20250410;

	while (in >> s) {
		cout << s << endl;
	}

	save("0410.cpp");
}

// cout << s << endl; -> xvalue를 사용하는 코드의 결과는 정의되어 있지 않음

================================
저장한 시간 : 2025-04-10 오전 11:38:31 목요일
================================

//------------------------------------------------------------------------
// 2025.04.10													
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

// [문제] "0410.cpp"에 있는 단어(공백으로 분리된 char의 집합)를 모두 읽어라.
// 단어를 우리가 만든 STRING에 저장하라.
// 다음 코드가 문제없이 실행되면 좋겠다.

//--------
int main()
//--------
{
	STRING s;

	ifstream in{ "0410.cpp" };
	if (not in)
		return 20250410;

	while (in >> s) {
		cout << s << endl;
	}

	save("0410.cpp");
}

// cout << s << endl; -> xvalue를 사용하는 코드의 결과는 정의되어 있지 않음

================================
저장한 시간 : 2025-04-10 오전 11:39:19 목요일
================================

//------------------------------------------------------------------------
// 2025.04.10													
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

// [문제] "0410.cpp"에 있는 단어(공백으로 분리된 char의 집합)를 모두 읽어라.
// 단어를 우리가 만든 STRING에 저장하라.
// 다음 코드가 문제없이 실행되면 좋겠다.

//--------
int main()
//--------
{
	STRING s;

	ifstream in{ "0410.cpp" };
	if (not in)
		return 20250410;

	while (in >> s) {
		cout << s << endl;
	}

	save("0410.cpp");
}

// cout << s << endl; -> xvalue를 사용하는 코드의 결과는 정의되어 있지 않음

================================
저장한 시간 : 2025-04-10 오전 11:39:57 목요일
================================

//------------------------------------------------------------------------
// 2025.04.10													
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

// [문제] "0410.cpp"에 있는 단어(공백으로 분리된 char의 집합)를 모두 읽어라.
// 단어를 우리가 만든 STRING에 저장하라.
// 다음 코드가 문제없이 실행되면 좋겠다.

//--------
int main()
//--------
{
	STRING s;

	ifstream in{ "0410.cpp" };
	if (not in)
		return 20250410;

	while (in >> s) {
		cout << s << endl;
	}

	save("0410.cpp");
}

// cout << s << endl; -> xvalue를 사용하는 코드의 결과는 정의되어 있지 않음

================================
저장한 시간 : 2025-04-10 오전 11:40:33 목요일
================================

//------------------------------------------------------------------------
// 2025.04.10													
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

// [문제] "0410.cpp"에 있는 단어(공백으로 분리된 char의 집합)를 모두 읽어라.
// 단어를 우리가 만든 STRING에 저장하라.
// 다음 코드가 문제없이 실행되면 좋겠다.

//--------
int main()
//--------
{
	STRING s;

	ifstream in{ "0410.cpp" };
	if (not in)
		return 20250410;

	while (in >> s) {
		cout << s << endl;
	}

	save("0410.cpp");
}

// cout << s << endl; -> xvalue를 사용하는 코드의 결과는 정의되어 있지 않음

================================
저장한 시간 : 2025-04-10 오전 11:49:19 목요일
================================

//------------------------------------------------------------------------
// 2025.04.10													
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

// [문제] "0410.cpp"에 있는 단어(공백으로 분리된 char의 집합)를 모두 메모리에 저장하라.
// 단어를 50개만 읽는다.
// 단어를 길이기준 오름차순으로 정렬하라.
// 정렬한 단어를 모두 출력하라.

array<STRING, 50 > words;

//--------
int main()
//--------
{
	STRING s;

	ifstream in{ "0410.cpp" };
	if (not in)
		return 20250410;
	
	for (STRING& word : words)
		in >> word;

	std::sort(words.begin(), words.end(), [](const STRING& lhs, const STRING& rhs) {
		return lhs.size() < rhs.size();
		});

	for (const STRING& word : words)
		cout << word << endl;

	save("0410.cpp");
}

// cout << s << endl; -> xvalue를 사용하는 코드의 결과는 정의되어 있지 않음

================================
저장한 시간 : 2025-04-10 오전 11:55:17 목요일
================================

//------------------------------------------------------------------------
// 2025.04.10													
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

// [문제] "0410.cpp"에 있는 단어(공백으로 분리된 char의 집합)를 모두 메모리에 저장하라.
// 단어를 50개만 읽는다.
// 단어를 길이기준 오름차순으로 정렬하라.
// 정렬한 단어를 모두 출력하라.

array<STRING, 50 > words;

//--------
int main()
//--------
{
	STRING s;

	ifstream in{ "0410.cpp" };
	if (not in)
		return 20250410;
	
	for (STRING& word : words)
		in >> word;

	std::sort(words.begin(), words.end());

	for (const STRING& word : words)
		cout << word << endl;

	save("0410.cpp");
}

// cout << s << endl; -> xvalue를 사용하는 코드의 결과는 정의되어 있지 않음

================================
저장한 시간 : 2025-04-10 오전 11:59:46 목요일
================================

//------------------------------------------------------------------------
// 2025.04.10													
// 중간고사 - 4월 24일 목요일 (8주 2일)
// 과제설명 - 4월 10일 목요일
//------------------------------------------------------------------------
// class STRING - STL 정식 컨테이너처럼 동작하는 자료구조
//------------------------------------------------------------------------
// 컴파일 환경은 이렇게 맞춰주세요
// VS 버젼 - 17.3.0 이후
// Release / x64, C++ 언어 표준 - /std::C++latest, SDL검사 - 아니요 
//------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

// [문제] "0410.cpp"에 있는 단어(공백으로 분리된 char의 집합)를 모두 메모리에 저장하라.
// 단어를 50개만 읽는다.
// 단어를 길이기준 오름차순으로 정렬하라.
// 정렬한 단어를 모두 출력하라.

array<STRING, 50 > words;

//--------
int main()
//--------
{
	STRING s;

	ifstream in{ "0410.cpp" };
	if (not in)
		return 20250410;
	
	for (STRING& word : words)
		in >> word;

	std::sort(words.begin(), words.end());			// 기본 정렬 -> < 또는 less{}를 이용

	for (const STRING& word : words)
		cout << word << endl;

	save("0410.cpp");
}

// cout << s << endl; -> xvalue를 사용하는 코드의 결과는 정의되어 있지 않음